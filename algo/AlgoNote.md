# Algo Note

## 1. Binary Search

### Basic Notes

四要素：

1. 左端点和右端点：决定了搜索的区间
2. while循环的终止条件：决定了终止时左右端点的相对位置，根据初始搜索区间调整，防止漏掉元素或越界、死循环
3. 三段判断：分别与中点数值对比，对左右端点进行更新或返回（找到元素）
4. while循环外的返回：根据具体要求返回端点或-1或进行修改后返回

注意：

- 防止溢出，更新mid：mid = left + (right - left) / 2

三种模版（from LeetCode）

### Day 1

**35.搜索插入位置**

二分法

- 在一个有序数组中找第一个大于等于 $\textit{target}$ 的下标

- 利用模版：vanilla+while循环外的返回值为left

    vanilla情况下：

    - 末尾返回值为left：第一个大于target的值
    - 末尾返回值为right：最后一个小于target的值

**69.ｘ的平方根**

二分法

- 寻找满足$k^2\le x$的最大$k$值
- 下界为0，上界为$x$

数学：使用换底公式，取整数，最后稍作判断

### Day 2

**167.两数之和-ii-输入有序数组**

二分法

- 对每一个元素，只搜索其右端的元素
- 由于数组有序，且不允许重复使用元素，在此元素右端可以使用二分搜索
- 每次搜索的$target$是$target-arr[i]$

双指针法

- 初始时，双指针位于数组的一头一尾
- 每次迭代测试两指针的值之和是否为target
    - 若较之大：右指针左移（使和减小）
    - 若较之小：左指针右移（使和增大）
- 正确性：必然有解

**278.第一个错误的版本**

二分法

- 目标：找到第一个False / 最后一个True + 1
- 设定区间为$[1,n]$
- 在vanilla基础上，删去相等返回分支，最终返回left (or right + 1)

### Day 3

**349.两个数组的交集**

二分法

- 对两个数组分别排序

- 随意选择一个数组（应该选择较短的那个）进行遍历

    - 对每个元素，二分搜索另一个数组

    - 若此元素在另一个数组中也存在，判断其是否已经出现在结果数组中（有序性）

    - 若重复则抛弃

- **nlogn**

Hash or Set法

- 对一个数组直接生成set / unordered_set等集合数据结构
- 遍历另一个数组，判断是否在set中
- **线性**

**350.两个数组的交集II**

双指针法

- 利用有序性
- 对两个数组进行排序
- 迭代两个数组，短的数组结束时结束
    - 若两指针相等，则加入结果
    - 若不等，移动值较小的指针
- **nlogn**

**367.有效的完全平方数**

二分法

- 使用**69**题的开方法，返回处稍作修改即可

**374.猜数字大小**

二分法

- 初始时左端点为1，右端点为n
- 修改判断条件即可

**441.排列硬币**

二分法

- 寻找满足$\dfrac{(1+k)\times k}{2}\le x$的最大$k$值
- 注意计算判断值时要使用long类型，否则溢出

### Day 4

**392. 判断子序列**

**704. 二分查找**

**788. 旋转数字**

**914. 卡牌分组**

**1122. 数组的相对排序**

**744. 寻找比目标字母大的最小字母**

**852. 山脉数组的峰顶索引**