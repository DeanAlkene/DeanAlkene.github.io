<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Learn Rust</title>
    <link href="/2021/09/23/LearnRust/"/>
    <url>/2021/09/23/LearnRust/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="learn-rust">Learn Rust</h1><h2 id="基础部分">1. 基础部分</h2><h3 id="变量与类型条件语句">1.1 变量与类型、条件语句</h3><ul><li><p>使用<code>let</code>声明变量（常量），<code>let mut</code>声明变量，相当于C++ <code>auto</code></p></li><li><p>同时初始化：</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (<span class="keyword">mut</span> &lt;var1&gt;, <span class="keyword">mut</span> &lt;var2&gt;, ...) = (&lt;val1&gt;, &lt;val2&gt;, ...);</span><br></pre></td></tr></table></figure></p></li><li><p>基础类型是数字、布尔和字符串，数字类型为<code>i/u/f</code>+字节数，<code>i/u/f+size</code>为体系结构指定</p></li><li><p>可以在声明变量时指定类型，使用<code>: + type</code>标注在变量名后</p></li><li><p><code>char</code>的长度为32bit（21bit补全）</p></li><li><p><code>&amp;str</code>相当于字符串的指针or引用（字符串字面值），不会改变，编译时长度确定</p></li><li><p><code>tuple</code>类型使用<code>&lt;tuple&gt;.&lt;idx&gt;</code>来访问元素</p></li><li><p><code>if-else</code>语句可以作为表达式赋值，block中写入值（不加<code>;</code>），整个赋值语句后加<code>;</code></p></li></ul><a id="more"></a><h3 id="结构体与枚举">1.2 结构体与枚举</h3><ul><li><p>结构体有三种类型，经典结构体、元组结构体（无字段名），单元结构体</p></li><li><p>经典结构体的定义与C类似，不过字段之间以逗号隔开，类型声明在字段名后，即</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &lt;<span class="title">name</span></span>&gt; &#123;</span><br><span class="line">&lt;field1&gt; : &lt;type1&gt;,</span><br><span class="line">&lt;field2&gt; : &lt;type2&gt;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>声明最后不加分号（与C++不同）</p><p>实例化时采用类似结构，且可以不遵守字段的定义顺序，即</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &lt;var&gt; = &lt;name&gt; &#123;</span><br><span class="line">&lt;field1&gt; : &lt;val1&gt;,</span><br><span class="line">&lt;field2&gt; : &lt;var2&gt;,</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li><li><p>元组结构体的定义包含每个字段的类型，使用括号，并用逗号隔开每个字段的类型，即</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &lt;<span class="title">name</span></span>&gt;(&lt;type1&gt;, &lt;type2&gt;, ...);</span><br></pre></td></tr></table></figure></p><p>注意，结构体名称必须与括号连在一起，声明是需要分号结尾</p><p>实例化时按照顺序实例化各个字段，即</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &lt;var&gt; = &lt;name&gt;(&lt;val1&gt;, &lt;val2&gt;, ...);</span><br></pre></td></tr></table></figure></p></li><li><p>与C/C++中的枚举不同，这里的每个枚举变体都可以是不同类型的值，即枚举作为一种代数数据类型（加类型）也即是将某个类型进行划分（不相交集）</p></li><li><p>枚举的直接定义方式：（末尾无分号！）</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &lt;<span class="title">name</span></span>&gt; &#123;</span><br><span class="line">    &lt;unit-variant&gt;,</span><br><span class="line">    &lt;tuple-variant&gt;(&lt;type1&gt;, &lt;type2&gt;, ...),</span><br><span class="line">    &lt;cstruct-variant&gt; &#123;</span><br><span class="line">        &lt;field1&gt; : &lt;type1&gt;,</span><br><span class="line">        &lt;field2&gt; : &lt;type2&gt;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对应的直接实例化方式：</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &lt;var-name-u&gt; = &lt;name&gt;::&lt;unit-variant&gt;;</span><br><span class="line"><span class="keyword">let</span> &lt;var-name-t&gt; = &lt;name&gt;::&lt;tuple-variant&gt;(&lt;val1&gt;, &lt;val2&gt;, ...);</span><br><span class="line"><span class="keyword">let</span> &lt;var-name-c&gt; = &lt;name&gt;::&lt;cstruct-variant&gt; &#123;</span><br><span class="line">    &lt;field1&gt; : &lt;val1&gt;,</span><br><span class="line">    &lt;field2&gt; : &lt;val2&gt;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p></li><li><p>用结构体定义枚举：</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &lt;<span class="title">tuple</span></span>-s&gt;(&lt;type1&gt;, &lt;type2&gt;, ...);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &lt;<span class="title">cstruct</span></span>-s&gt; &#123;</span><br><span class="line">    &lt;field1&gt; : &lt;type1&gt;,</span><br><span class="line">    &lt;field2&gt; : &lt;type2&gt;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &lt;<span class="title">name</span></span>&gt; &#123;</span><br><span class="line">    &lt;unit-variant&gt;,</span><br><span class="line">    &lt;simple-variant&gt;(&lt;type&gt;),</span><br><span class="line">    &lt;tuple-variant&gt;(&lt;tuple-s&gt;),</span><br><span class="line">    &lt;cstruct-variant&gt;(&lt;cstruct-s&gt;),</span><br><span class="line">    ... <span class="comment">// maybe directly defined variants</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对应的实例化应该先实例化各个结构体，再传入：</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &lt;s-name-t&gt; = &lt;tuple-s&gt;(&lt;val1&gt;, &lt;val2&gt;, ...);</span><br><span class="line"><span class="keyword">let</span> &lt;s-name-c&gt; = &lt;cstruct-s&gt; &#123;</span><br><span class="line">    &lt;field1&gt; : &lt;val1&gt;,</span><br><span class="line">    &lt;field2&gt; : &lt;val2&gt;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &lt;var-name-s&gt; = &lt;name&gt;::&lt;simple-variant&gt;(&lt;val&gt;);</span><br><span class="line"><span class="keyword">let</span> &lt;var-name-t&gt; = &lt;name&gt;::&lt;tuple-variant&gt;(&lt;s-name-t&gt;);</span><br><span class="line"><span class="keyword">let</span> &lt;var-name-c&gt; = &lt;name&gt;::&lt;cstruct-variant&gt;(&lt;s-name-c&gt;);</span><br><span class="line">... <span class="comment">// maybe other variants&#x27; instantiation</span></span><br></pre></td></tr></table></figure></p></li><li><p>枚举怎么用？重新思考：对于一种类型的数据存在有限多种变体，用统一的接口来处理这些变体。注意，由于这里枚举的一般性，实现这样的接口时，对每种枚举变体的类型都需要处理</p></li><li><p>通过 <code>#[derive(Debug)]</code> 语法可以在代码执行期间查看某些在标准输出中无法查看的值。在 <code>println!</code> 中使用语法 <code>&#123;:#?&#125;</code> 以可读的方式格式化数据（如添加在enum、struct的定义前）</p></li></ul><h3 id="函数">1.3 函数</h3><ul><li><p>函数定义：</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn &lt;func&gt;(&lt;arg1&gt; : &lt;type1&gt;, &lt;arg2&gt; : &lt;type2&gt;, ...) -&gt; &lt;ret-type&gt; &#123;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>隐式返回：总是返回<strong>代码块</strong>中的最后一个表达式，末尾不加分号</p></li></ul><h3 id="数组">1.4 数组</h3><ul><li><p>两种声明方法，第二种方法初始化一个<code>&lt;size&gt;</code>长度的全为<code>&lt;init-val&gt;</code>的数组</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &lt;name&gt; = [&lt;val1&gt;, &lt;val2&gt;, ...];</span><br><span class="line"><span class="keyword">let</span> &lt;name&gt; = [&lt;init-val&gt;; &lt;size&gt;];</span><br></pre></td></tr></table></figure></p><p>即，一组<strong>长度不可更改</strong>的同类型数据</p></li><li><p>数组的签名：<code>[T; size]</code></p></li></ul><h3 id="向量">1.5 向量</h3><ul><li><p>两种声明+初始化方法</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[&lt;val1&gt;, &lt;val2&gt;, ...]; <span class="comment">// 1-1</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[&lt;init-val&gt;; &lt;size&gt;]; <span class="comment">// 1-2</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">Vec</span>::new(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p></li><li><p>长度可变的数组</p></li><li><p>尾部插入/弹出：<code>Vec::push(i)</code>, <code>Vec::pop()</code></p></li><li><p>格式化打印：使用<code>&#123;:?&#125;</code></p></li><li><p>安全访问：<code>Vec::get(i)</code>，返回值为<code>Option</code>枚举</p></li></ul><h3 id="hashmap">1.6 HashMap</h3><ul><li><p>声明一个空哈希映射</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> &lt;name&gt; : HashMap&lt;K, V&gt; = HashMap::new();</span><br></pre></td></tr></table></figure></p></li><li><p>插入键值对：<code>&lt;name&gt;.insert(&lt;key&gt;, &lt;value&gt;)</code></p></li><li><p>根据键获取值：<code>&lt;name&gt;.get(&lt;key&gt;)</code>，返回值是一个<code>Option&lt;&amp;V&gt;</code>类型，若对无效键使用此方法，会返回<code>None</code></p></li><li><p>删除条目：<code>&lt;name&gt;.remove(&lt;key&gt;)</code></p></li><li><p>字符串字面值到<code>String</code>的两种方法：</p><ol type="1"><li><code>&amp;str.to_string()</code></li><li><code>String::from(&amp;str)</code></li></ol></li><li><p>键列表、值列表：<code>&lt;name&gt;.keys()</code>, <code>&lt;name&gt;.values()</code></p></li></ul><h3 id="循环">1.7 循环</h3><h4 id="loop循环">1.7.1 Loop循环</h4><ul><li><p>创建无限循环，手动终止或使用<code>break</code>终止</p></li><li><p><code>break</code>可以在断点处返回值（类似<code>return</code>的语法），多个断点返回值必须是同一类型</p></li><li><p>返回值的绑定：可以将<code>loop</code>表达式绑定到某个变量上</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span> &lt;val1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ul><h4 id="while循环">1.7.2 While循环</h4><p>与通常情况下的while循环一致</p><h4 id="for循环">1.7.3 For循环</h4><p>使用迭代器的循环，迭代器作为临时变量在<code>for</code>语句中被定义</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;iter&gt; <span class="keyword">in</span> &lt;collection&gt;.iter() <span class="comment">// iterate over &lt;collection&gt;</span></span><br><span class="line"><span class="keyword">for</span> &lt;num-iter&gt; <span class="keyword">in</span> i..j <span class="comment">// iterate from i to j - 1</span></span><br></pre></td></tr></table></figure><h2 id="异常处理">2. 异常处理</h2><h3 id="panicoption和result">2.1 Panic、Option和Result</h3><ul><li><p>使用<code>panic!</code>宏输出错误消息、清理资源、退出程序</p></li><li><p><code>Option&lt;T&gt;</code>是一个枚举类型，用于处理<strong>可能为空</strong>的值，包含两种变体</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>使用模式匹配访问<code>Some(var)</code>中的<code>var</code>（数据）：</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> &lt;val&gt; &#123;</span><br><span class="line">    &lt;pattern1&gt; =&gt; ..., <span class="comment">// match arm1</span></span><br><span class="line">    &lt;pattern2&gt; =&gt; ..., <span class="comment">// match arm2</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于一个<code>Option</code>枚举，<code>match</code>中的pattern分别为<code>Some&lt;var&gt;</code>和<code>None</code>，这样就可以将数据绑定至<code>var</code>这个变量（scope仅在match块）</p></li><li><p>使用<code>match</code>匹配时需要注意：</p><ol type="1"><li>匹配是从上至下的，因此先匹配具体/特殊，再匹配一般</li><li>必须涵盖输入的所有可能值</li></ol></li><li><p><code>&lt;pattern&gt;</code>可以使用<code>_</code>来匹配任何值（放在最后一个arm）</p></li><li><p>使用<code>if let</code>进行单个模式匹配</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> &lt;pattern&gt; = &lt;val&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若匹配成功，则执行语句块中的语句</p></li><li><p><code>Option::unwarp()</code>：直接访问<code>Some</code>中的数据，若为<code>None</code>则panic</p></li><li><p><code>Option::except(&lt;str&gt;)</code>：自定义panic输出消息</p></li><li><p><code>Option::unwrap_or(&lt;val&gt;)</code>：若为<code>None</code>则返回默认值</p></li><li><p><code>Result&lt;T, E&gt;</code>是一个枚举类型，用于处理可能的错误</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T), <span class="comment">// obtain value of T</span></span><br><span class="line">    <span class="literal">Err</span>(E), <span class="comment">// error of E</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><code>Ok</code>变体的<code>unwrap</code>和<code>except</code>返回其中的值，而<code>Err</code>变体将引起panic</p></li></ul><h2 id="内存管理">3. 内存管理</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Paper Reading Note</title>
    <link href="/2020/10/23/Paper-Reading-Note/"/>
    <url>/2020/10/23/Paper-Reading-Note/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="paper-reading">Paper Reading</h1><h2 id="neurosurgeon-collaborative-intelligence-between-the-cloud-and-mobile-edge-asplos-2017">1. Neurosurgeon: Collaborative Intelligence Between the Cloud and Mobile Edge <span class="citation" data-cites="ASPLOS">@ASPLOS</span> 2017</h2><h3 id="研究背景">研究背景</h3><ul><li>大量的人工智能应用采用了深度神经网络（DNN）</li><li>DNN的推理计算是非常消耗计算资源的任务</li><li>当前（论文完成时）的解决方案是在云端进行全部处理</li><li>移动端的计算能力越来越强：考虑将一部分计算任务交给移动端处理，而不是全部在云端进行</li></ul><h3 id="当前解决方案云端处理">当前解决方案——云端处理</h3><ul><li>通常情况下，数据传输的时延高于计算时延</li><li>云端处理有着非常大的计算优势，但往往被数据传输带来的消耗抵消</li><li>本地移动处理时延低、能量消耗小</li></ul><a id="more"></a><h3 id="层级粒度的计算分割">层级粒度的计算分割</h3><ul><li>以典型CV应用为例：前卷积后全连接<ul><li>在不同位置的不同类型的神经网络层，有着不同的计算和数据特性</li><li>在移动GPU上，卷积和池化层的时延小，而全连接层的时延大</li><li>卷积层常出现在网络的前端，而全连接常在后端</li><li>由于池化层的存在，在网络后端的数据大小往往小于输入</li><li>前端减少数据大小&amp;后端层均时延大==&gt;本地处理前端、云处理后端</li></ul></li><li>降低时延的分割：<ul><li>在移动端进行减少数据大小&amp;计算时延低的计算过程，后传输至云端</li><li>在云端进行时延较大的计算过程</li></ul></li><li>降低能量消耗的分割：恰当的分割能减少能量消耗（相较全云端处理）</li><li>更多领域的DNN：<ul><li>卷积和池化带来的数据大小变化--&gt;计算量的变化</li><li>只有全连接层的网络（语音、NLP），每层时延和数据大小变化不大</li><li><strong>划分网络要考虑网络的拓扑结构和组成的网络层类型</strong></li></ul></li></ul><h3 id="neurosurgeon系统">Neurosurgeon系统</h3><ul><li>部署阶段：对移动设备和云端设备的性能进行测量，并生成回归模型（对数回归）</li><li>运行时：<ul><li>分析神经网络结构、组成</li><li>使用模型估计时延&amp;能耗</li><li>结合网络带宽和数据中心载荷选择最佳分割点</li><li>分段执行</li></ul></li><li>优势<ul><li>在大多数情况下能找到最优分割点</li><li>大多数情况下降低了时延和能耗</li><li>能在网络带宽变化时保持时延的稳定</li><li>能适应数据中心的载荷变化</li><li>提高数据中心吞吐量</li></ul></li></ul><h2 id="aaiot-accelerating-artificial-intelligence-in-iot-systems-ieee-lwc-2019">2. AAIoT: Accelerating Artificial Intelligence in IoT Systems <span class="citation" data-cites="IEEE">@IEEE</span> LWC 2019</h2><h3 id="背景">背景</h3><ul><li>目前的offloading模型一般只考虑两层结构，即端-云结构</li><li>本文提出一种动态规划算法，以最小化系统响应时间为目标，分割神经网络并分配到一个多层IoT设备构成的网络上</li></ul><h3 id="模型">模型</h3><ul><li><p>每个设备：接受输入并将输出传给下一个设备</p></li><li><p>神经网络的输入在第一个设备输入，也必须将输出传回第一个设备</p></li><li><p>神经网络的单层是不可分割的、每层的计算是有顺序的</p></li><li><p>处于更高层级的设备（往往）拥有更强的算力，因此将计算任务部分转移到高层设备是以通信时延换取计算时延的减少，而往低层设备转移则不会带来任何好处：神经网络层的分配是有序的（算力低--&gt;高）</p></li><li><p>优化目标： <span class="math display">\[  \mathcal{T}_{\text{calcu}}=\sum_{i=1}^nc_i^{a_i}  \]</span></p><p><span class="math display">\[  \mathcal{T}_{\text{trans}}=\sum_{i=1}^n\sum_{j=a_{i-1}}^{a_i-1}(s_i+s_{n+1})/p_j\quad\quad(a_0=1)  \]</span></p><p><span class="math display">\[  \mathcal{T}=\mathcal{T}_{\text{calcu}}+\mathcal{T}_{\text{trans}}  \]</span></p><p>其中，<span class="math inline">\(c_i\)</span>为第<span class="math inline">\(i\)</span>层在设备<span class="math inline">\(a_i\)</span>上的计算时延，<span class="math inline">\(a_i\)</span>为第<span class="math inline">\(i\)</span>被分配到的设备，<span class="math inline">\(a_{i+1}\ge a_i\)</span>是规定的层级顺序，<span class="math inline">\(s_i\)</span>为第<span class="math inline">\(i\)</span>层的输入数据大小，<span class="math inline">\(s_{n+1}\)</span>为输出结果大小，<span class="math inline">\(p_j\)</span>为<span class="math inline">\(d_j\)</span>与<span class="math inline">\(d_{j+1}\)</span>之间的传输带宽</p></li></ul><h3 id="算法">算法</h3><ul><li>目标：给定每层在不同设备上的执行时间<span class="math inline">\(C\)</span>，每层输出数据的大小<span class="math inline">\(S\)</span>，每个设备之间的带宽<span class="math inline">\(P\)</span>，找到一个分配<span class="math inline">\(A\)</span>使得<span class="math inline">\(\mathcal{T}\)</span>最小</li><li>动态规划：<ul><li>状态：<span class="math inline">\(h_i^j\)</span>，第<span class="math inline">\(i\)</span>层的输入被传输到设备<span class="math inline">\(j\)</span>上的<strong>最小响应时间</strong>，当<span class="math inline">\(i=n+1\)</span>时表示网络输出的传输最小响应时间</li><li>状态初始化：初始化第一层输入被传输到各个设备上的最小响应时间（递推）</li><li>状态转移：<ul><li>若只在第一个设备上计算并不发生offloading：由上一个状态直接递推</li><li>若在其他设备上进行计算（<span class="math inline">\(h_i^j\)</span>, <span class="math inline">\(i,j&gt;1\)</span>）：要么由本设备（<span class="math inline">\(d_j\)</span>）计算<span class="math inline">\(l_i\)</span>的输入，要么由底层设备<span class="math inline">\(d_{j-1}\)</span>算好<span class="math inline">\(l_i\)</span>的输入传输到本设备<span class="math inline">\(d_j\)</span></li></ul></li></ul></li><li>完成动态规划计算后，可以自顶向下找到一个分配的方案</li></ul><h3 id="改进方向">改进方向</h3><ul><li>考虑一个设备被多个低层设备共享时的情况：多任务、资源不独占</li><li>优化能耗</li></ul><h2 id="modnn-local-distributed-mobile-computing-system-for-deep-neural-network-date-2017">3. MoDNN: Local Distributed Mobile Computing System for Deep Neural Network <span class="citation" data-cites="DATE">@DATE</span> 2017</h2><h3 id="背景-1">背景</h3><p>在本地分布式计算系统中进行神经网络的推理，而非云端</p><p>WLAN——机会移动网络（Opportunistic Mobile Network）</p><ul><li>进入网络范围自动接入</li><li>传输速率高、能耗低</li></ul><p>MapReduce</p><ul><li>分布式计算框架</li><li>Map分割计算任务、Reduce合并计算结果</li></ul><p>卷积层&amp;全连接层</p><ul><li>卷积层主要消耗计算时间</li><li>全连接层主要消耗内存空间，且其参数有一定稀疏性</li></ul><h3 id="系统架构">系统架构</h3><p>网络结构</p><ul><li>单GO (Group Owner)多worker结构</li><li>GO作为无线接入点，而worker则寻找GO接入</li><li>worker接入后传输元数据</li></ul><p>卷积层的分割——BODP</p><ul><li>根据worker节点的计算能力，按比例、横/竖向分割输入</li></ul><p>全连接层的分割——MSCC&amp;FGCP</p><ul><li>由于全连接层的参数较多、传输需要更多时间，可以根据矩阵的稀疏程度，恰当地使用稀疏矩阵（链表）的方式传输</li><li>根据设备对于普通矩阵、稀疏矩阵计算的不同时间，得到是否采用稀疏矩阵的阈值</li><li>MSCC：对权重矩阵做谱聚类，找出非零值的聚类并最小化聚类外非零值数量，随后根据聚类的稀疏程度转换储存方式、得到分配给各worker的计算量</li><li>FGCP：对每个聚类的Outlier（行相同、列不在聚类内）先找到合适的储存方式，再根据非零值的数量，将非零值较多的列分配给GO计算（均衡GO与workers的负载）</li></ul><p>控制流程</p><ul><li>检测到卷积层后启动BODP进行分割、结合后续层进行计算</li><li>检测到全连接层后，先用MSCC进行分割、分配，再用FGCP</li></ul><h3 id="贡献改进方向">贡献&amp;改进方向</h3><ul><li>提出了新的分割算法</li><li>有效降低了数据传输量</li><li>可以均衡GO与worker的工作负载</li><li>仅在本地分布式系统（基于WLAN）计算，如何推广以利用互联网上的边缘/云设备计算？</li><li>矩阵分割等操作要使用SVD、K-Means等算法，是否时间复杂度较高？</li></ul><h2 id="deepdecision-a-mobile-deep-learning-framework-for-edge-video-analytics-infocom-2018">4. DeepDecision: A Mobile Deep Learning Framework for Edge Video Analytics <span class="citation" data-cites="INFOCOM">@INFOCOM</span> 2018</h2><h3 id="背景-2">背景</h3><p>增强现实等应用需要视频的实时推理，而移动端的计算能力不足，往往向服务器offloading，同时</p><ul><li>需要平衡准确度与延迟</li><li>网络延迟往往比计算延迟大得多</li><li>将视频视作一等公民，可压缩、编码，但需要权衡准确度</li></ul><h3 id="模型与算法">模型与算法</h3><p>自由度</p><ul><li>视频分辨率：分辨率越高准确度越高，但能耗也越高、计算时间增加</li><li>不同大小的模型：小模型速度快但准确度不高</li><li>Offloading：以网络通信时延的代价换取更高的准确度和推理时间</li><li>视频压缩：offloading时，低比特率可以减少传输时间，但降低准确率</li><li>视频采样率：可以减少采样率以减少计算时间</li></ul><p>模型</p><ul><li>目标：最大化预测精度与摄像机采样率</li><li>限制条件：<ul><li>推理速度高于摄像机采样率</li><li>网络带宽、耗电量、流量费用的限制</li><li>采样率和精度的最低要求</li></ul></li><li>本地有多个不同大小的模型、服务器上有大模型，可以进行offloading</li></ul><p>算法</p><ul><li>对远程模型：先找到满足限制条件的最大采样率，再搜索分辨率和比特率的最佳组合</li><li>对每一个本地模型：比特率可以设置为最大，先找满足限制的最大采样率，在找最佳分辨率</li></ul><h3 id="实验结果">实验结果</h3><ul><li>计算时间和能耗与分辨率线性相关</li><li>只提高分辨率对准确度提升影响有限，但若同时提高比特率，则可以获得较大提升</li><li>网络传输时延占总时延的大多数，决策时必须高度关注网络状况</li><li>由于视频应用的实时性，延迟往往带来准确度的下降</li><li>网络情况差时，采用视频压缩可以保持帧数稳定</li><li>对比其他方法，DeepDecision能根据网络情况等因素调整模型使用策略，保持精度处于较高水平</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Note</tag>
      
      <tag>Paper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm Note</title>
    <link href="/2020/10/23/Algorithm-Note/"/>
    <url>/2020/10/23/Algorithm-Note/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="algorithm-note">Algorithm Note</h1><h2 id="binary-search">1. Binary Search</h2><h3 id="basic-notes">Basic Notes</h3><p>四要素：</p><ol type="1"><li>左端点和右端点：决定了搜索的区间</li><li>while循环的终止条件：决定了终止时左右端点的相对位置，根据初始搜索区间调整，防止漏掉元素或越界、死循环</li><li>三段判断：分别与中点数值对比，对左右端点进行更新或返回（找到元素）</li><li>while循环外的返回：根据具体要求返回端点或-1或进行修改后返回</li></ol><p>注意：</p><ul><li>防止溢出，更新mid：mid = left + (right - left) / 2</li></ul><p>三种模版（from LeetCode）</p><a id="more"></a><h3 id="day-1">Day 1</h3><p><strong>35.搜索插入位置</strong></p><p>二分法</p><ul><li><p>在一个有序数组中找第一个大于等于 <span class="math inline">\(\textit{target}\)</span> 的下标</p></li><li><p>利用模版：vanilla+while循环外的返回值为left</p><p>vanilla情况下：</p><ul><li>末尾返回值为left：第一个大于target的值</li><li>末尾返回值为right：最后一个小于target的值</li></ul></li></ul><p><strong>69.ｘ的平方根</strong></p><p>二分法</p><ul><li>寻找满足<span class="math inline">\(k^2\le x\)</span>的最大<span class="math inline">\(k\)</span>值</li><li>下界为0，上界为<span class="math inline">\(x\)</span></li></ul><p>数学：使用换底公式，取整数，最后稍作判断</p><h3 id="day-2">Day 2</h3><p><strong>167.两数之和II 输入有序数组</strong></p><p>二分法</p><ul><li>对每一个元素，只搜索其右端的元素</li><li>由于数组有序，且不允许重复使用元素，在此元素右端可以使用二分搜索</li><li>每次搜索的<span class="math inline">\(target\)</span>是<span class="math inline">\(target-arr[i]\)</span></li></ul><p>双指针法</p><ul><li>初始时，双指针位于数组的一头一尾</li><li>每次迭代测试两指针的值之和是否为target<ul><li>若较之大：右指针左移（使和减小）</li><li>若较之小：左指针右移（使和增大）</li></ul></li><li>正确性：必然有解</li></ul><p><strong>278.第一个错误的版本</strong></p><p>二分法</p><ul><li>目标：找到第一个False / 最后一个True + 1</li><li>设定区间为<span class="math inline">\([1,n]\)</span></li><li>在vanilla基础上，删去相等返回分支，最终返回left (or right + 1)</li></ul><h3 id="day-3">Day 3</h3><p><strong>349.两个数组的交集</strong></p><p>二分法</p><ul><li><p>对两个数组分别排序</p></li><li><p>随意选择一个数组（应该选择较短的那个）进行遍历</p><ul><li><p>对每个元素，二分搜索另一个数组</p></li><li><p>若此元素在另一个数组中也存在，判断其是否已经出现在结果数组中（有序性）</p></li><li><p>若重复则抛弃</p></li></ul></li><li><p><strong>nlogn</strong></p></li></ul><p>Hash or Set法</p><ul><li>对一个数组直接生成set / unordered_set等集合数据结构</li><li>遍历另一个数组，判断是否在set中</li><li><strong>线性</strong></li></ul><p><strong>350.两个数组的交集II</strong></p><p>双指针法</p><ul><li>利用有序性</li><li>对两个数组进行排序</li><li>迭代两个数组，短的数组结束时结束<ul><li>若两指针相等，则加入结果</li><li>若不等，移动值较小的指针</li></ul></li><li><strong>nlogn</strong></li></ul><p>Hash</p><ul><li>对第一个数组建立Hash表，统计元素出现的个数</li><li>遍历第二个列表，如果能找到对应元素，则加入答案，之后减少Hash表相应项的次数1，若次数减为0，则删去这一项</li></ul><p><strong>367.有效的完全平方数</strong></p><p>二分法</p><ul><li>使用<strong>69</strong>题的开方法，返回处稍作修改即可</li></ul><p><strong>374.猜数字大小</strong></p><p>二分法</p><ul><li>初始时左端点为1，右端点为n</li><li>修改判断条件即可</li></ul><p><strong>441.排列硬币</strong></p><p>二分法</p><ul><li>寻找满足<span class="math inline">\(\dfrac{(1+k)\times k}{2}\le x\)</span>的最大<span class="math inline">\(k\)</span>值</li><li>注意计算判断值时要使用long类型，否则溢出</li></ul><h3 id="day-4">Day 4</h3><p><strong>392. 判断子序列</strong></p><p>双指针法</p><ul><li>根据子序列的定义，一旦s中的元素与t中的元素对应，则只需要考虑t在此后的元素了（贪心）</li><li>判断条件为s的指针是否达到了末尾</li></ul><p>动态规划</p><ul><li>一次打表，N次查询</li></ul><p><strong>704. 二分查找</strong></p><p>二分法</p><ul><li>直接使用模版</li></ul><p><strong>788. 旋转数字</strong></p><p>暴力法</p><ul><li>如果是旋转数字，那么每一位不为3/4/7，并且必须要含有2/5/8</li><li>使用<code>to_string()</code>将整型转换为string</li></ul><p>动态规划</p><p>*<strong>914. 卡牌分组</strong></p><p>Hash+最小公约数</p><ul><li>注意到分组的牌数必须为每种牌面类型个数的约数</li><li>为了每组牌数一致，此约数为每种牌数的最小公约数</li><li>先统计牌数，再遍历+累计求gcd</li></ul><p><strong>1122. 数组的相对排序</strong></p><p>计数排序</p><ul><li>先统计arr1每种元素的个数</li><li>遍历arr2，按个数输出</li><li>再遍历bucket，找出没有输出的放在末尾</li></ul><p><strong>744. 寻找比目标字母大的最小字母</strong></p><p>二分法</p><ul><li>LeetCode模版2+特殊情况判断</li></ul><p><strong>852. 山脉数组的峰顶索引</strong></p><p>二分法</p><ul><li>LeetCode模版2（适用于访问右边值的判断）</li></ul><h3 id="day-5">Day 5</h3><p><strong>1237. 找出给定方程的正整数解</strong></p><p>二分法</p><ul><li>由于函数在两个方向上的偏导数都为正，按行（y）搜索时，可以不断收缩右边界</li><li>即y-1时的解x一定比y时的解x大</li><li>按行（y）遍历，每次只搜索右边界以内的数组</li></ul><p>双指针法</p><ul><li>x从左向右，y从右向左，其中一个到底时停止</li><li>若f值小于目标，则前移x，大于时后移y，等于时均移动并记录</li></ul><p><strong>1337. 方阵中战斗力最弱的 K 行</strong></p><p>排序</p><ul><li>遍历矩阵，统计数据</li><li>自定义比较函数并排序</li><li>取前k</li></ul><p>二分+排序</p><ul><li>统计数据时，可以使用二分搜索找第一个出现的0（所有0必在1后）便可知道1的数量</li></ul><p><strong>1351. 统计有序矩阵中的负数</strong></p><p>二分法</p><ul><li>对每行，找第一个负数出现的位置，即可知道负数的个数</li><li>二分使用LeetCode模版2</li></ul><p>分治法</p><p>倒序遍历</p><ul><li>根据两方向偏导数符号相同</li><li>上一行第一个负数的位置必然比下一行大</li><li>线性复杂度</li></ul><h3 id="day-6">Day 6</h3><p><strong>74. 搜索二维矩阵</strong></p><p>二分法</p><ul><li>根据矩阵元素排列特征：直接展开为一维数组二分</li><li>中点元素：<span class="math inline">\(mat[mid / n][mid\% n]\)</span></li></ul><p>*<strong>275. H指数 II</strong></p><p>二分法</p><ul><li>根据题意：寻找<strong>第一个</strong><span class="math inline">\(i\)</span>使得<span class="math inline">\(cite[i]\ge n-i\)</span>，并返回<span class="math inline">\(n-i\)</span>，即H指数</li></ul><p><strong>34. 在排序数组中查找元素的第一个和最后一个位置</strong></p><p>二分法</p><ul><li>寻找左右边界即可</li></ul><p><strong>162. 寻找峰值</strong></p><p>二分法</p><ul><li>虽然存在多个峰值，但输出任意即可，因此使用852的代码</li><li>注意右边界应该设置为倒数第二个元素（闭区间&amp;&amp;不保证峰值不在边界）</li></ul><p><strong>240. 搜索二维矩阵 II</strong></p><p>双指针法</p><ul><li>类似1237的双指针法（矩阵形态一致）</li><li>注意指针初值及终止条件即可</li></ul><h3 id="day-7">Day 7</h3><p><strong>Review</strong></p><p>普通二分：寻找指定元素</p><ul><li>用于加速有序序列的查找</li></ul><p>第一个/最后一个：</p><ul><li>返回值的不同有所不同</li></ul><p>最左/最右：</p><ul><li>修改更新边界的语句</li></ul><p>访问相邻元素的查找：</p><ul><li>注意边界、区间和判断语句</li></ul><p>不完全单调：</p><ul><li>局部单调二分</li></ul><h3 id="day-8">Day 8</h3><p>*<strong>209. 长度最小的子数组</strong></p><p>前缀和+二分法</p><ul><li><p><strong>前缀和</strong>：适用于区间&amp;求和问题，前缀和数组单调递增，可使用二分查找降低复杂度</p><p><span class="math inline">\(sum[j]-sum[i]=\sum[i,j),\quad i\le j\)</span></p></li><li><p>据题意，需要找到区间<span class="math inline">\([i,j)\)</span>使得<span class="math inline">\(sum[j]-sum[i]\ge s\)</span>且区间长度最小</p></li><li><p>遍历左端点<span class="math inline">\(i\)</span>，每次迭代固定左端点，二分查找<span class="math inline">\(j\)</span>使其为第一个<span class="math inline">\(sum[j]\ge sum[i]+s\)</span>的下标</p></li><li><p>答案为迭代中产生的最小长度</p></li><li><p>两个细节</p><ol type="1"><li>查找<span class="math inline">\(j\)</span>时只需要从<span class="math inline">\(i+1\)</span>开始</li><li>当查找到的<span class="math inline">\(j\)</span>已经在最右端，但之前并未找到结果，则可跳出循环返回0</li></ol></li></ul><p>双指针法</p><ul><li>根据和的单调性，调整左右指针，并取最小区间大小</li><li>区间<span class="math inline">\([left,right)\)</span>，初值为0</li><li>若当前和小于目标值，加右端点并右移<span class="math inline">\(right\)</span></li><li>若当前和大于等于目标值，更新最小区间长度，减左端点并右移<span class="math inline">\(left\)</span></li><li>停止条件：和小于目标值但<span class="math inline">\(right\)</span>已经在最右端了</li></ul><p>*<strong>475. 供暖器</strong></p><p>二分法</p><ul><li>先排序以确保单调性</li><li>对一间房子而言，要么由左边的供暖要么由右边的供暖</li><li>对每一间房子：<ul><li>找到第一个位置大于等于它的供暖器，同时也可以得到最后一个位置小于它的供暖器</li><li>取距离的最小值作为离它最近的供暖器距离</li><li>注意找到的位置为边界时的特殊处理（均置为最大整数，且两种情况不同时出现）</li></ul></li><li>最后取这些最小值的最大值即为”最小半径“</li></ul><p>滑动窗口</p><ul><li>对每个房子：找最接近的供暖器供暖（并计算半径），若右边的供暖器更近，则更新供暖器指针</li><li>所有半径的最大值为答案</li></ul><h3 id="day-9">Day 9</h3><p><strong>875. 爱吃香蕉的珂珂</strong></p><p>二分法</p><ul><li>找到最小的K使得<span class="math inline">\(\sum_i\lceil\dfrac{sum[i]}{K}\rceil\le H\)</span></li><li>注意到向上取整构成了一个单调<strong>非增</strong>序列</li><li>使用找左边界的二分法，每次检查取整之和与<span class="math inline">\(H\)</span>的关系缩小范围</li><li>注意：上取整计算方法为<code>(a + b - 1) / b</code></li></ul><p><strong>1283. 使结果不超过阈值的最小除数</strong></p><p>二分法</p><ul><li>与<strong>875</strong>完全一致</li></ul><p>*<strong>1590. 使数组和能被 P 整除</strong></p><p>前缀和+Hash+数学</p><ul><li>找到最小区间<span class="math inline">\([i,j)\)</span>使得<span class="math inline">\([sum-\sum[i,j)]\%p=0\)</span>，实际上是同余问题</li><li>先判断数组和是否能被整除或小于除数（无解）</li><li>若数组和<span class="math inline">\(sum\%p\neq 0\)</span>，令之为<span class="math inline">\(mod\)</span>，问题转化为求一个最小区间<span class="math inline">\([i,j)\)</span>其和被<span class="math inline">\(p\)</span>除后余数为<span class="math inline">\(mod\)</span>，即<span class="math inline">\((prefix[j]-prefix[i])\%p=mod\)</span></li><li>维护一个Hash表，记录余数为key时离当前最近的位置，枚举右端点计算前缀和及它的余数<span class="math inline">\(curMod\)</span>，并更新Hash表使得<span class="math inline">\(curMod\)</span>对应位置最近</li><li>所要寻找的<span class="math inline">\(targetMod\)</span>为<ul><li>若<span class="math inline">\(curMod\ge mod\)</span>，<span class="math inline">\(curMod-mod\)</span></li><li>若<span class="math inline">\(curMod&lt;mod\)</span>，<span class="math inline">\(p+curMod-mod\)</span>（此时<span class="math inline">\(curMod-mod&lt;0\)</span>）</li></ul></li><li>若能找到则更新最小区间</li><li>注意：Hash表初值，余数为0的位置为0（迭代从前缀数组下标为1处开始）</li></ul><p>*<strong>974. 和可被 K 整除的子数组</strong></p><p>前缀和+Hash+数学</p><ul><li>求能被k整除的区间总数</li><li>即对于区间<span class="math inline">\([i,j)\)</span>，<span class="math inline">\(sum[i]\%K=sum[j]\%K\)</span></li><li>维护Hash表，记录当前位置之前余数为<span class="math inline">\(key\)</span>的子数组数，初值余数为0的个数为1（前缀数组位置0处取余为0）</li><li>枚举右端点，计算前缀和及对应余数<ul><li>注意：C++中对负数取余还是负数，为统一，取余写作<code>(a % b + b) % b</code></li></ul></li><li>若Hash表中能找到当前前缀和的余数，则更新答案，后更新Hash表，否则新增<span class="math inline">\(key\)</span>为余数个数为1的项</li></ul><h3 id="day-10">Day 10</h3><p>*<strong>1011. 在 D 天内送达包裹的能力</strong></p><p>二分法</p><ul><li>找到一个最小的每次运输量，能将传送带上的货物划分为小于等于D堆（连续划分）</li><li>注意到运输量越大、划分的堆数越少且不同的运输量可能对应同一划分数，即为单调不增序列</li><li>对运输量进行二分，左端点为最大货物重量、右端点为货物总重量</li><li>每次检测<span class="math inline">\(mid\)</span>的运输量下能划分为多少堆（遍历统计）</li><li>注意：采用插板法划分时，最终区间数=板数+1</li></ul><p>*<strong>1292. 元素和小于等于阈值的正方形的最大边长</strong></p><p>二维前缀和+二分/枚举剪枝/滑动窗口</p><ul><li><strong>二维前缀和</strong>：对于二维矩阵<span class="math inline">\(mat_{m\times n}\)</span>，计算每个位置左上方子矩阵的元素和<ul><li>区间<span class="math inline">\([i_1,i_2)[j_1,j_2)\)</span>为<span class="math inline">\(mat[i_1:i_2-1][j_1:j_2-1]\)</span>的和</li><li>前缀和矩阵<span class="math inline">\(p[i][j]\)</span>的值：区间<span class="math inline">\([0,i)[0,j)\)</span>的和（<span class="math inline">\(i\in[0,m],j\in[0,n]\)</span>，当<span class="math inline">\(i\)</span>或<span class="math inline">\(j\)</span>为0时，矩阵值为0）</li><li>初始化：<span class="math inline">\(p[i][j]=p[i-1][j]+p[i][j-1]-p[i-1][j-1]+mat[i-1][j-1]\)</span></li><li>求任意子矩阵元素和<span class="math inline">\(\sum[i_1,i_2)[j_1,j_2)=p[i_2][j_2]-p[i_1][j_2]-p[i_2][j_1]+p[i_1][j_1]\)</span></li></ul></li><li>二分法：随着边长的增加<span class="math inline">\(1\rightarrow\min(m,n)\)</span>，正方形元素和小于等于阈值这一命题将由T变为F<ul><li>对边长值进行二分，每次检查是否存在满足边长为<span class="math inline">\(mid\)</span>，且和小于等于阈值的子矩阵</li></ul></li><li>枚举剪枝：枚举每一个元素作为左上角点，固定此点，枚举边长并测试<ol type="1"><li>若在一次边长枚举中，和已经超过阈值，则不需要再枚举（矩阵值全正）</li><li>边长枚举的起始点为目前的最大边长+1</li></ol></li><li>滑动窗口：沿着所有斜率为-1的线枚举左上、右下端点的滑动窗口<ul><li>若滑动窗口的和大于阈值，则收缩左端点</li><li>否则扩张右端点</li></ul></li></ul><h3 id="day-11">Day 11</h3><p>*<strong>1482. 制作 m 束花所需的最少天数</strong></p><p>二分法</p><ul><li>给定开花日期，找最少天数，获得<span class="math inline">\(m\)</span>个不相交的、长度<span class="math inline">\(\ge k\)</span>的连续子区间</li><li>使对天数进行二分（区间：最小到最大开花日期），天数对是否能满足要求呈T-&gt;F序列</li><li>每次检查给定<span class="math inline">\(mid\)</span>天能获得的满足要求的区间数，并与目标对比即可</li></ul><p>*<strong>153. 寻找旋转排序数组中的最小值</strong></p><ul><li>数组的特性：分两段单调递增，左端恒大于右端</li><li>若某元素小于第一个元素的值，其必在右端序列中</li></ul><p>二分法1</p><ul><li>对每个<span class="math inline">\(mid\)</span>检查其与第一个元素值的关系</li><li>若<span class="math inline">\(mid\)</span>在右端，则收缩右边界，否则收缩左边界</li><li>若采用闭区间二分，返回<span class="math inline">\(left\)</span>对应元素</li><li>注意数组长度为0&amp;没有旋转（在0处旋转）的特殊情况</li></ul><p>二分法2</p><ul><li>对此类数组中任意的一个区间，只有以下三种情况<ol type="1"><li><span class="math inline">\(left\le mid&lt; right\)</span></li><li><span class="math inline">\(left \le mid \ge right\)</span></li><li><span class="math inline">\(left\ge mid&lt; right\)</span></li></ol></li><li>对于情况1、3，应该收缩右端点（包含<span class="math inline">\(mid\)</span>，对闭区间二分时，数组的特性保证不会死循环）</li><li>对于情况2，收缩左端点</li><li>结果应该是<span class="math inline">\(right\)</span>对应的值</li></ul><p>*<strong>33. 搜索旋转排序数组</strong></p><p>二分法</p><ul><li>对任意一个区间，其必然部分单调</li><li>对于二分过程中的<span class="math inline">\(mid\)</span>，若其值<strong>不小于</strong>左端点，则<span class="math inline">\([left,mid]\)</span>单调递增；若其值<strong>不大于</strong>右端点，则<span class="math inline">\([mid,right]\)</span>单调递增</li><li>同理，也能判断<span class="math inline">\(target\)</span>在区间中是否处于单调序列，并配合与<span class="math inline">\(mid\)</span>的值收缩区间边界</li></ul><h3 id="day-12">Day 12</h3><p><strong>1300. 转变数组后最接近目标值的数组和</strong></p><p>二分法</p><ul><li><span class="math inline">\(value\)</span>值的取值范围在<span class="math inline">\([0,\max(arr)]\)</span>之间（小于零则必然离正数<span class="math inline">\(target\)</span>越来越远，大于最大值则不会改变数组的和）</li><li>随着<span class="math inline">\(value\)</span>的增加，改变后数组的和也会增加，因此构成了<strong>单调递增</strong>序列，可以使用二分法（vanilla）</li><li>每次二分检查<span class="math inline">\(mid\)</span>时，直接遍历数组计算，并与<span class="math inline">\(target\)</span>比较，若直接找到和<span class="math inline">\(target\)</span>值一样的方案，则可以直接返回</li><li>否则会找到一个区间，这时需要重新计算<span class="math inline">\(right\)</span>（区间左边界）、<span class="math inline">\(left\)</span>（区间右边界）对应的改变后数组的和并进行比较返回（可以不考虑边界情况，他们也满足单调的特性，而且没有数组越界风险）</li></ul><p>前缀和+二分</p><ul><li>先排序，再求前缀和，那么每次检查的时间复杂度可以降至<span class="math inline">\(\mathcal{O}(\log N)\)</span></li><li>检查时计算改变后数组的和：<ul><li>令<span class="math inline">\(i:=lower\_bound(arr, mid)\)</span>（找到第一个大于等于<span class="math inline">\(mid\)</span>的位置）</li><li><span class="math inline">\(sum(mid)=prefix[mid]+(len(arr) - i)*mid\)</span></li></ul></li></ul><p>*<strong>1552. 两球之间的磁力</strong></p><p>二分法</p><ul><li>对任意一个球，其最小磁力应该是与相邻球产生的</li><li>对给定数组，最小磁力的范围应该在<span class="math inline">\([1,\max(pos)-\min(pos)]\)</span>区间内</li><li>现要把<span class="math inline">\(m\)</span>个球放入篮子中求最大最小磁力，转换视角，找到一个最大的最小磁力值，使得篮子中总共能放入<span class="math inline">\(\ge m\)</span>个球</li><li>随着最小磁力值的增加，能放入的球数呈<strong>单调不增</strong>的序列，采用寻找右边界的二分，并返回<span class="math inline">\(right\)</span></li><li>检测是否能放入<span class="math inline">\(\ge m\)</span>个球时，对排序过后的每个元素遍历，每次检查当前位置与上一位置的距离差是否大于等于<span class="math inline">\(mid\)</span>并计数（贪心：总是从第一个位置开始放，这样才能放得最多）</li></ul><p>*<strong>378. 有序矩阵中第K小的元素</strong></p><p>二分法</p><ul><li>根据矩阵行、列的单调性，对于矩阵中任意元素，其左上方子矩阵内的所有元素都小于等于它</li><li>要求的第K小元素，可转化为求一个元素，值小于等于它的有至少K个元素</li><li>矩阵元素的最小值和最大值分别为<span class="math inline">\(left=mat[0][0]\)</span>和<span class="math inline">\(right=mat[n-1][n-1]\)</span></li><li>对于任意值<span class="math inline">\(mid\)</span>处于最小值最大值区间内，可以用<span class="math inline">\(\mathcal{O}(n)\)</span>的时间求出值小于等于<span class="math inline">\(mid\)</span>的矩阵元素个数<ul><li>从矩阵左下角开始遍历，直到超出矩阵</li><li>若当前元素值小于等于<span class="math inline">\(mid\)</span>，则累加<span class="math inline">\(i+1\)</span>（其上方和本身都<span class="math inline">\(\le mid\)</span>），并向右移一列检查</li><li>否则，向上移动直到找到满足条件的元素</li></ul></li><li>对<span class="math inline">\(mid\in[left, right]\)</span>，<span class="math inline">\(|\{mat[i][j]|mat[i][j]\le mid\}|\)</span>随<span class="math inline">\(mid\)</span>构成<strong>单调不减序列</strong>，因此可以使用找最左边界的二分法得到结果</li><li>关于正确性的思考<ul><li>为何“最左边界”就是答案？序列中发生突变的点必然对应一个矩阵中的元素</li><li>若矩阵中有重复元素，且答案要求的恰好就是这个元素，为何正确？<span class="math inline">\(K\)</span>可能不在序列中，但最终一定会找到大于<span class="math inline">\(K\)</span>的第一个元素（返回<span class="math inline">\(left\)</span>）它对应的<span class="math inline">\(mid\)</span>是正确的值</li></ul></li></ul><h3 id="day-13">Day 13</h3><p><strong>1095. 山脉数组中查找目标值</strong></p><ul><li>先通过<strong>852</strong>题的方法找到山脉的峰顶索引，此索引将数组分为左边递增右边递减两个子数组</li><li>现在左边二分搜索，若找不到，在右边二分搜索</li><li>总共进行了3次二分搜索</li></ul><h3 id="day-14">Day 14</h3><p>Review</p><h3 id="day-15">Day 15</h3><p>*<strong>658. 找到K个最接近的元素</strong></p><p>二分法+双指针</p><ul><li><p>先对<span class="math inline">\(x\)</span>与数组第一个、最后一个数比较，对特殊情况进行特殊处理</p></li><li><p>使用二分搜索找到最接近<span class="math inline">\(x\)</span>的元素下标<span class="math inline">\(i\)</span>，并确定双指针法初始区间为<span class="math inline">\([i-k,i+k]\)</span>（若不引起越界）</p></li><li><p>计算<span class="math inline">\(x\)</span>与左右边界值的差的绝对值进行比较</p><ul><li>若与左边界的绝对值差较小，收缩右边界</li><li>若与右边界的绝对值差较小，收缩左边界</li><li>若相等，收缩右边界</li></ul><p>直到区间长度为<span class="math inline">\(k\)</span></p></li><li><p>另一种方法：找到最接近的元素后，向左、向右扩张区间</p></li><li><p>不使用二分：双指针初始区间为整个数组</p></li></ul><h3 id="day-16">Day 16</h3><p>*<strong>1631. 最小体力消耗路径</strong></p><p>二分法+BFS/DFS</p><ul><li>注意到若体力值越大，越有可能到达终点，即随体力值增长呈F--&gt;T变化</li><li>判断能否到达终点可使用DFS或者BFS，而寻找最小体力值则可使用二分法</li><li>对体力值进行二分，初始左边界为0，右边界为最大落差，每次使用BFS判断能否在给定体力值下到达终点，若可以则收缩右边界，否则收缩左边界，最终返回<span class="math inline">\(left\)</span></li><li>进行BFS时，在入队条件判断时加入体力值计算、对比即可</li></ul><h3 id="day-17">Day 17</h3><p>*<strong>56. 合并区间</strong></p><p>排序</p><ul><li>先按照区间左端点大小进行排序</li><li>合并时，遍历排序后的区间数组<ul><li>若结果为空或当前区间与结果数组最后一个区间不能合并，则向结果中新加入当前区间</li><li>否则能合并，更新结果数组最后一个区间右端点（<strong>注意</strong>：当前遍历区间可能包含于结果数组最后一个区间，所以需要取最大值更新）</li></ul></li></ul><p>*<strong>1640. 能否连接形成数组</strong></p><p>Hash表</p><ul><li>由于两个数组中，数字均互不相同，可以将<span class="math inline">\(pieces\)</span>数组中每个数组的第一个元素作为key，其索引作为value建立一个hash表</li><li>遍历<span class="math inline">\(arr\)</span>数组，若当前元素在hash表中对应一个数组，则进行匹配，若其中出现不匹配或无法在hash表中找到数组，则失败</li></ul><p><strong>1502. 判断能否形成等差数列</strong></p><p>排序</p><ul><li>排序后检查相邻元素差是否相同即可</li></ul><p><strong>1636. 按照频率将数组升序排序</strong></p><p>排序</p><ul><li>先统计元素出现的频次（平移后使用数组or使用hash表）</li><li>将hash表扁平化、元素pair化，自定义比较函数并排序</li><li>根据排序结果，组成结果数组返回</li></ul><p>*<strong>778. 水位上升的泳池中游泳</strong></p><p>二分法+BFS</p><ul><li>随着时间的增长，水位越来越高，游到终点的可能性也越大，呈F--&gt;T变化</li><li>要找最小时间，则对时间进行二分，初始左端点为<span class="math inline">\(grid[0][0]\)</span>，初始右端点为<span class="math inline">\(\max(grid[i][j])\)</span>，若当前能走到终点则收缩右端点，否则收缩左端点，最终返回<span class="math inline">\(left\)</span></li><li>BFS时需在入队时判断水位与高度的大小</li><li>若左端点设置为<span class="math inline">\(0\)</span>，则必须在进入BFS循环前的入队判断，起点的高度是否不高于水位，否则不能移动，若设置为起点值，则不需要判断</li></ul><h3 id="day-18">Day 18</h3><p>*<strong>668. 乘法表中第k小的数</strong></p><p>二分法</p><ul><li><p>乘法表也满足两个方向上偏导数均为正的特性</p></li><li><p>见<strong>658</strong>，思路相似，对<span class="math inline">\([1,m\times n]\)</span>进行寻找左边界的二分，每次检查小于等于<span class="math inline">\(mid\)</span>的元素的个数</p></li><li><p>除了使用“双指针”进行自左下角的遍历，注意到对于某一列<span class="math inline">\(k\)</span>，在这一列中小于等于<span class="math inline">\(mid\)</span>的元素个数应该是<span class="math inline">\(\min(mid/k,n)\)</span>则可以逐列统计</p></li></ul><p>*<strong>976. 三角形的最大周长</strong></p><p>排序+贪心</p><ul><li>将数组由高至低排序</li><li>由于要取得最大周长，则三条边越大越好，但必须满足两短边之和大于第三边</li><li>从最大值开始遍历，若其后方2个数能与之组成三角形，则返回</li><li>否则检查下一个值和它后方的2个数</li><li>只检查后方2个数的原因：<ul><li>若能形成三角形，则更小的边只会造成周长减小甚至不能形成三角形</li><li>若不能形成三角形，更小的边也不能形成三角形</li></ul></li></ul><p><strong>1491. 去掉最低工资和最高工资后的工资平均值</strong></p><p>遍历</p><ul><li>遍历找最大、最小值、求和，最后求值</li><li>不用排序！！！</li></ul><p><strong>1528. 重新排列字符串</strong></p><p>遍历</p><ul><li>新建一个字符串，遍历原字符串，将字符放入对应位置即可</li></ul><p><strong>1403. 非递增顺序的最小子序列</strong></p><p>排序+贪心</p><ul><li>使用贪心法，要求的序列所包含的元素应该越大越好，这样它的长度才会短</li><li>而题目只要求子序列，则可以将数组倒序排列，从最大的开始遍历即可获得答案</li><li>遍历前先计算数组总体的和，遍历过程中不断计算前缀和，并与剩下的和进行比较，直到前缀和严格大于剩下的元素和，返回前缀</li></ul><h3 id="day-19">Day 19</h3><p><strong>242. 有效的字母异位词</strong></p><p>Hash</p><ul><li>第一次统计s的字母个数</li><li>第二次根据t的字母减去Hash表中的相应值</li><li>第三次判断Hash表是否全0</li><li>若使用Unicode字符，则仍然使用Hash表</li></ul><p><strong>1030. 距离顺序排列矩阵单元格</strong></p><p>排序</p><ul><li>先生成矩阵，在自定义比较函数排序（lambda表达式的用法）</li><li>也可以使用BFS进行层次遍历、Hash等方法</li></ul><p><strong>1356. 根据数字二进制下 1 的数目排序</strong></p><p>排序</p><ul><li>自定义排序函数</li><li>求二进制中的1：先与1再右移，直到为0</li><li>也可先打表，直接索引表项比较：递推式<span class="math inline">\(cnt[i]=cnt[i &gt;&gt; 1]+(i\&amp;1)\)</span></li></ul><h3 id="day-20">Day 20</h3><p><strong>1471. 数组中的 k 个最强值</strong></p><p>排序</p><ul><li>先排序找中位数</li><li>再使用自定义比较函数排序取前k个值即可</li></ul><p>排序+双指针</p><ul><li>先排序找中位数</li><li>双指针初始分别位于数组起始，计算强度值<ul><li>若<span class="math inline">\(|arr[left]-m|&gt;|arr[right]-m|\)</span>则取左，左指针右移</li><li>否则取右（相等时由于<span class="math inline">\(arr[left]\le arr[right]\)</span>，不必考虑），右指针左移</li><li>直到取了k个值</li></ul></li></ul><p><strong>922. 按奇偶排序数组 II</strong></p><p>遍历</p><ul><li>遍历数组，按照奇偶放到结果数组的合适位置</li></ul><p>*<strong>1370. 上升下降字符串</strong></p><p>排序</p><ul><li>桶排序方法：先统计字符串中字母出现的次数</li><li>循环直到结果字符串的长度与原长度一致<ul><li>先从头遍历桶，将不为空的桶取出一个元素接在结果字符串后面</li><li>再从尾遍历桶，将不为空的桶取出一个元素接在结果字符串后面</li></ul></li></ul><h3 id="day-21">Day 21</h3><p>Review</p><h3 id="day-22">Day 22</h3><p>*<strong>485. 最大连续1的个数</strong></p><p>遍历</p><ul><li>注意这里遍历的写法<ul><li>在元素为1时增加当前连续1的长度，并更新最大连续1的长度</li><li>在元素为0时置当前连续1长度为0</li></ul></li></ul><p><strong>495. 提莫攻击</strong></p><p>遍历</p><ul><li>考虑到重叠攻击的问题，每次取相邻攻击时间与攻击有效时间的最小值累加即可</li></ul><p>*<strong>189. 旋转数组</strong></p><p>遍历1：k次移动</p><ul><li>对数组进行k次右移一位操作</li><li>超时</li></ul><p>遍历2：临时保存末尾k个元素</p><ul><li>按照右移一位的情况推广，先保存末尾k个数</li><li>将剩下的数移动到相应位置</li><li>将k个数放在前k个数处</li><li><strong>注意</strong>：若<span class="math inline">\(k&gt;n\)</span>，则移动<span class="math inline">\(k\% n\)</span>次即可</li></ul><p>遍历3：跳跃移动</p><ul><li>一旦位于<span class="math inline">\(i\)</span>的元素要移动到<span class="math inline">\((i+k)\%n\)</span>位置，必然导致后续每隔<span class="math inline">\(k\)</span>个元素发生后移<span class="math inline">\(k\)</span>的动作，但最终会移动到<span class="math inline">\(i\)</span>位置而停止</li><li>可以将旋转过程看做<span class="math inline">\(i\%k\)</span>相同的元素组成子数组自行旋转</li><li>则从第一个元素开始，每次进行跳跃移动，完毕后从下个元素继续</li><li>每次移动均计数，直到所有元素都被遍历</li><li>同样，<span class="math inline">\(k=k\%n\)</span></li></ul><p>遍历4：3次反转</p><ul><li>先对整个数组反转</li><li>在分别对前<span class="math inline">\(k\)</span>个和后<span class="math inline">\(n-k\)</span>个元素组成的子数组反转</li><li>同样地，<span class="math inline">\(k=k\%n\)</span></li></ul><h3 id="day-23">Day 23</h3><p>*<strong>414. 第三大的数</strong></p><p>遍历</p><ul><li>设三个数，分别代表第一大、第二大和第三大的数</li><li>遍历时根据当前元素与第一、二、三大的数的大小关系更新这三个变量</li><li>注意1：由于有重复值，但结果需要去重，判断大小关系时遇到相等（区间边界）则跳过</li><li>注意2：由于元素值可能为INT_MIN，则使用long long类型，初始化时设置为比INT_MIN更小</li></ul><p><strong>628. 三个数的最大乘积</strong></p><p>遍历</p><ul><li>与<strong>414</strong>相似，但判断是要考虑区间边界（不去重）</li><li>由于元素可能为负数，最大乘积可能出现在最大、第二大、第三大元素和最大、最小、第二小的乘积之间，因此遍历时要设置5个变量，逐一更新</li></ul><p>*<strong>396. 旋转函数</strong></p><p>数学</p><ul><li><p>错位相减法：定义<span class="math inline">\(F(k) = \sum_{i=0}^{n-1}i\times A[(i+k)\%n]\)</span></p><p>则<span class="math inline">\(F(k)-F(k-1)=\sum_{i=0}^{n-1}A[i]-A[n-k]+(n-1)\times A[n-k]=\sum_{i=0}^{n-1}A[i]-n\times A[n-k]\)</span></p></li><li><p>倒序遍历数字计算<span class="math inline">\(F(k)\)</span>即可</p></li><li><p>注意int溢出</p></li></ul><h3 id="day-24">Day 24</h3><p>*<strong>645. 错误的集合</strong></p><p>排序</p><ul><li>先统计每个元素的出现次数</li><li>遍历桶，找到统计次数为0和2对应的元素即可</li></ul><p>修改数组</p><ul><li>原地翻转的思想，利用数的符号作为额外信息以标记出现次数</li><li>遍历数组<ul><li>若第一次访问，则将当前元素值的绝对值对应下标处的元素应该为正数，将其符号取反</li><li>若第二次访问，则会发现那个位置的元素值已经是负数，说明找到了重复值</li></ul></li><li>最终遍历一次，找出唯一的正数，对应下标即为丢失的数字</li></ul><p>位运算</p><ul><li>异或法：https://leetcode-cn.com/problems/set-mismatch/solution/cyi-huo-fa-xiang-jie-by-feng-feng-19/</li></ul><p><strong>448. 找到所有数组中消失的数字</strong></p><p>修改数组</p><ul><li>原地翻转思想，先遍历数组，对每个元素绝对值对应的下标处符号取反</li><li>再遍历一次找出所有符号为正的下标位置即可</li></ul><p><strong>118. 杨辉三角</strong></p><p>模拟</p><ul><li>根据定义进行迭代计算即可</li></ul><h3 id="day-25">Day 25</h3><p><strong>442. 数组中重复的数据</strong></p><p>修改数组</p><ul><li>遍历数组，若当前元素绝对值对应下标处的符号为正，则说明第一次访问，将其取反</li><li>若当前元素绝对值对应下标处的符号为负，则说明已经访问过，将其加入答案</li></ul><p>*<strong>274. H 指数</strong></p><p>排序</p><ul><li>先对引用量进行桶排序，注意，如果一个人只有n篇文章，那么其H指数不可能超过n，因此超过n的引用量统计在n的桶内</li><li>？？？</li></ul><p>*<strong>119. 杨辉三角 II</strong></p><p>模拟</p><p>数学</p><ul><li>第<span class="math inline">\(n\)</span>行 (<span class="math inline">\(n&gt;0\)</span>) 的元素为<span class="math inline">\(C_{n}^{i}\)</span></li><li>递推<span class="math inline">\(C_{n}^{i+1}=\dfrac{n-i}{i+1}C_{n}^{i}\)</span></li></ul><h3 id="day-26">Day 26</h3><p><strong>303. 区域和检索 - 数组不可变</strong></p><p>前缀和</p><ul><li>参考<strong>209</strong></li></ul><p><strong>304. 二维区域和检索 - 矩阵不可变</strong></p><p>二维前缀和</p><ul><li>参考<strong>1292</strong></li></ul><p><strong>661. 图片平滑器</strong></p><p>遍历</p><ul><li>对每一个元素遍历计算，判断其位置来确定求均值的范围</li><li>也可以直接在遍历循环中遍历计算，只需要在累加时判断是否越界即可</li></ul><h3 id="day-27">Day 27</h3><p>*<strong>453. 最小移动次数使数组元素相等</strong></p><p>遍历</p><ul><li><p>由于只考虑元素的相对大小（最终相等即可）</p></li><li><p>对N-1个元素加一相当于对剩下的一个元素减一</p></li><li><p>在这种角度来看，最小移动次数即将所有元素减至最小值的移动次数，即</p><p><span class="math inline">\(move=\sum_{i=0}^{N-1}arr[i]-\min(arr)\times N\)</span></p></li><li><p>为防止计算和时超出int范围，可以两次遍历</p></li></ul><p>*<strong>665. 非递减数列</strong></p><p>遍历</p><ul><li>可以观察到，需要调整的点都在“拐点”附近，即<span class="math inline">\(arr[i]&gt;arr[i+1]\)</span>的附近</li><li>对于这附近的值，有两种方法使得这一段数组变为非递减</li><li>？？？？</li></ul><p><strong>598. 范围求和 II</strong></p><p>遍历</p><ul><li>考虑到每个元素的值不减，则出现在操作区间中最多的元素值最大</li><li>这些元素就是所有操作区域的交集，则遍历操作列表，每次取最小区域即可</li><li>最小区域的大小即为答案</li></ul><h3 id="day-28">Day 28</h3><p>Review</p><h3 id="day-29">Day 29</h3><p><strong>566. 重塑矩阵</strong></p><p>遍历</p><ul><li>先检查是否能进行reshape</li><li>若能：<span class="math inline">\(res[i/c][i\%c]=nums[i/n][i\%n], i:0\rightarrow m\times n -1\)</span></li></ul><p><strong>268. 丢失的数字</strong></p><p>位运算</p><ul><li>参考<strong>645</strong></li><li>先将0异或0-n的所有数字，再异或数组中的所有数字即可得到丢失的数字（未成对消去的那一个）</li><li>或一次遍历，将初始值设为n，直接遍历数组异或元素和下标即可</li></ul><h3 id="day-30">Day 30</h3><p>*<strong>7. 整数反转</strong></p><p>数学</p><ul><li>对一个数进行翻转的基本流程是先取余加至翻转数末尾，再整除base</li><li>但这里要求只能使用int大小的空间，因此可能会出现溢出的情况</li><li>在一部分情况下，溢出会导致符号反转，因此可以利用这个判断，但这里溢出会导致运行时错误，因此要特殊判断</li><li>每次取得余数，即将加入翻转数末尾前，必须要判断这时的翻转数与INT_MAX/10和INT_MIN/10的关系，若已经超过则说明加上后必然溢出，则返回0。也有可能翻转数与上下界前几位相等，则要判断即将加入的余数是否超过7或低于-8（这种情况似乎永远不会发生），若是则溢出返回0。</li></ul><p>*<strong>9. 回文数</strong></p><p>字符串</p><ul><li>最简单的方法既是将数转换为字符串，然后双指针比较或反转比较</li></ul><p>数学</p><ul><li>简单的想法是将数翻转，然后比较原来的数与翻转数是否相等</li><li>注意负数可以直接返回false，同时若一个数末尾为0，那么如果它是回文数，开头也必须是0，这样的数只有0，所以也可以特判</li><li>更优的办法是只翻转一半的数字，即对数进行翻转直到翻转数大于等于原数，这意味着现在这两个数的位数相等或相差1，最后判断两数是否相等或翻转数/10与原数是否相等即可。</li></ul><h3 id="day-31">Day 31</h3><p>*<strong>231. 2的幂</strong></p><p>位运算1</p><ul><li>判断除了最高位之外的所有二进制为是否均为0，与&amp;右移</li></ul><p>位运算2</p><ul><li>取一个数二进制最右的1：<span class="math inline">\(n \&amp; (-n)\)</span></li><li>判断是否为<span class="math inline">\(n\)</span></li></ul><p>位运算3</p><ul><li>将一个数二进制最右的1置0：<span class="math inline">\(n\&amp;(n-1)\)</span></li><li>判断是否为0</li></ul><p>*<strong>342. 4的幂</strong></p><p>递归or循环</p><ul><li>递归：一个数是4的幂那么它也是2的幂，并且右移两位仍然是2的幂（终止条件，小于等于0为false，1为true）</li><li>循环：数0 or 模4除4直到余数不为0，判断是否只剩1</li></ul><p>位运算</p><ul><li>首先判断是2的幂，在与0xAAAAAAAA（偶数位为1）判断是否为0</li><li>或是与0x55555555（奇数位为1）判断是否为本身</li></ul><p>位运算+数学</p><ul><li><p>先判断是否为2的幂</p></li><li><p>分类讨论<span class="math inline">\(2^{2k}\)</span>和<span class="math inline">\(2^{2k+1}\)</span></p><ul><li><span class="math inline">\(2^{2k}\mod 3=((3+1)^k \mod 3)=1\)</span></li><li><span class="math inline">\(2^{2k+1}\mod 3=(2\times(3+1)^k\mod 3)=2\)</span></li></ul></li><li><p><span class="math inline">\((3+1)^k\mod3=(3\times(3+1)^{k-1}\mod 3)+((3+1)^{k-1}\mod 3)\)</span></p><p><span class="math inline">\(=((3+1)^{k-1}\mod 3)=\cdots=(3+1)\mod 3=1\)</span></p></li></ul><h3 id="day-32">Day 32</h3><p>*<strong>326. 3的幂</strong></p><p>循环</p><ul><li>除3直到余数不为0，判断是否只剩1</li></ul><p>数学1</p><ul><li>对数法，有精度问题</li></ul><p>数学2</p><ul><li>注意到不超过int范围的最大3的幂为<span class="math inline">\(3^{19}\)</span>，而3是质数，所以这个数的因数只有3的幂</li><li>因此只需要判断大于0与1162261467模n是否为0即可</li></ul><p><strong>504. 七进制数</strong></p><p>数学</p><ul><li>进制转换，注意0和符号处理</li></ul><h3 id="day-33">Day 33</h3><p>*<strong>263. 丑数</strong></p><p>数学</p><ul><li>因数：如果一个数只有2/3/5三种质因数，那么除掉所有这样的因子，最后应该为1</li></ul><p><strong>190. 颠倒二进制位</strong></p><p>位运算</p><h3 id="day-34">Day 34</h3><p><strong>191. 位1的个数</strong></p><p>位运算1</p><ul><li>与1&amp;右移1直到0，同时统计1的个数</li></ul><p>位运算2</p><ul><li>每次将最右端的1取反为0，直到整个数没有1（等于0），统计取反次数</li><li>取反方法：<span class="math inline">\(n:=n\&amp;(n-1)\)</span></li></ul><p><strong>461. 汉明距离</strong></p><p>位运算</p><ul><li>异或后统计1</li></ul><h3 id="day-35">Day 35</h3><p>*<strong>476. 数字的补数</strong></p><p>位运算</p><ul><li><p>注意：数与其补数相加二进制全1，即为<span class="math inline">\(2^k-1\)</span></p></li><li><p>方法1：统计数不包含前导0的位数，构造一个相同位数、全1的mask，异或即可</p><p>（边移位边构造mask，统计位数再构造）</p></li><li><p>方法2：根据相加的特性，用对数+1得到二进制位数，后构造mask异或（注意越界）</p></li></ul><p>*<strong>283. 移动零</strong></p><p>双指针</p><p>修改数组</p><h3 id="day-36">Day 36</h3><p>*<strong>477 汉明距离总和</strong></p><p>位运算</p><ul><li>若对每对数字进行计算，则时间复杂度太高</li><li>对数字的每一位，发现这一位上互相的汉明距离和可以计算，即1的个数乘以0的个数（每个1和所有0进行配对计算才为1）</li><li>则对每一位的1的个数进行统计，最后遍历统计数组计算汉明距离总和</li><li>注：若以位数为外循环则常数较大，以遍历数字为外循环更好</li></ul><p>*<strong>693. 交替位二进制数</strong></p><p>位运算1</p><ul><li>移位&amp;取最后一位，检查上一位和这一位是否相同</li></ul><p>位运算2</p><ul><li>向右移一位，并与原数异或，若交替出现0/1，则异或结果为全1</li><li>最终检查异或结果与异或结果+1的与是否为0即可（注意溢出）</li></ul><h3 id="day-37">Day 37</h3><p>*<strong>172. 阶乘后的零</strong></p><p>数学</p><ul><li>注意到阶乘实际上可以拆成每个数质因数的乘积，而要产生末尾0只有<span class="math inline">\(2\times 5\)</span>配对</li><li>初始想法则是从1到n统计2和5因子的个数，然后返回小的那个，但这样做时间复杂度过高</li><li>注意到有2因子的数每2个出现一次，而有5因子的数每5个出现一次，那么5因子的数量必定小于2因子的数量，因此只用统计5因子。但这样仍然不能通过所有测试</li><li>注意到每5个数有一个含有1个5因子的数，每25个有一个含有2个的，每125个有一个含有3个的......以此类推，总共的5因子数量为<span class="math inline">\(\sum_{i=1}^k\dfrac{n}{5^k}\)</span></li><li>而求5的幂可能会溢出，实现时先除以5统计个数，再将自身除5，等价于分母除5，直到为0</li></ul><p>*<strong>393. UTF-8 编码验证</strong></p><p>位运算</p><ul><li>首先，要获取一个uint_8开头连续1的个数，可以通过与0x80并累加、不断右移0x80直到与结果为0</li><li>获得开头连续1个数后，要判断是否多于4个、是否为1个或者数组是否足够长，若都满足，则对后面的（连续1个数-1）个数判断开头是否为10（需要准备两个mask）</li></ul><h3 id="day-38">Day 38</h3><p>*<strong>258. 各位相加</strong></p><p>数学1</p><ul><li>按照题意循环相加即可</li></ul><p>数学2</p><ul><li>注意到：<span class="math inline">\(x=\sum_{i=0}^{n-1}a_i\times 10^i\)</span>，将每位数相加：<span class="math inline">\(f(x)=\sum_{i=0}^{n-1}a_i\)</span>，可以观察到<span class="math inline">\(f(f(x))\equiv f(x)\equiv x\mod 9\)</span>（每次都从<span class="math inline">\(10^i,i&gt;0\)</span>中抽1出来，表现为能被9整除的数+每位数之和）</li><li>那么只需要对每个数对9取余即可，但需要注意0时结果为0，9的倍数时结果应该为9但取余为0，因此可以先左移一位再取余，之后右移，即<span class="math inline">\((x-1)\mod9+1\)</span></li></ul><p>*<strong>319. 灯泡开关</strong></p><p>数学</p><ul><li>灯泡只会在其编号的因数轮才会发生翻转</li><li>翻转奇数次最终灯泡是亮的，翻转偶数次最终是灭的</li><li>因此只有编号的因数个数为奇数时最终才是亮的</li><li>由于因数都是成对存在的，那么只有完全平方数的因数个数为奇数个（有一种分解为X=AA）</li><li>最终只用找n以内的完全平方数即可，即<span class="math inline">\(\lfloor \sqrt{n}\rfloor\)</span></li></ul><h3 id="day-39">Day 39</h3><p><strong>405. 数字转换为十六进制数</strong></p><p>位运算</p><ul><li><p>每次与0xf获得四位取得对应十六进制数，再将原数右移四位</p></li><li><p>注意特判0</p><p>注意应该是逻辑右移，因此先转换为unsigned（C/C++无逻辑移位）</p></li></ul><p><strong>171. Excel表列序号</strong></p><p>数学</p><ul><li>26进制转10进制即可，注意A对应的十进制数是1不是0</li></ul><h3 id="day-40">Day 40</h3><p>*<strong>168. Excel表列名称</strong></p><p>数学</p><ul><li>10进制转26进制，注意每一个字母对应值都相较26进制右移（+1）了一位，即A对应1，Z对应26</li><li>因此，每次除法之前，上一次的商要减一（使余数左移-1一位）</li></ul><p>*<strong>670. 最大交换</strong></p><p>贪心</p><ul><li><p>若只允许交换至多一次，则必须是最高位的最小数交换最低位的最大数；若数字不减排序则不必交换</p></li><li><p>因此，从最高位开始，找到每一个元素及其右边最远的、最大的数，若能找到则交换一次退出，若逐个遍历，时间复杂度平方级</p></li><li><p>注意到，考察右区间的最远最大值时，可以向左递推并及时更新最大数及其下标，构造一个数组，其元素值代表以下标为左端点闭区间内最大、最远（可能重复）的元素下标。</p><ul><li>从最低位开始遍历，若当前元素<strong>严格大于</strong>最大值，则更新最大值及下标，每次迭代向构造数组的对于位置填写右边最远最大值的下标</li><li>从最高位遍历，若当前元素右侧的最远最大值不是自己，并且值不相等，则交换并返回</li></ul><p>这样的时间复杂度为线性</p></li></ul><h3 id="day-41">Day 41</h3><p>*<strong>400. 第N个数字</strong></p><p>数学1</p><ul><li><p>一个<span class="math inline">\(k\)</span>位正数<span class="math inline">\(n\)</span>从高到低的第<span class="math inline">\(j\)</span>位（<span class="math inline">\(j\in[1,k]\)</span>）在这个序列中的位置可以计算为： <span class="math display">\[  idx=\sum_{i=1}^{k-1}(n-10^i)+n+j-1=\sum_{i=0}^{k-1}(n-10^i)+j  \]</span> 可以被解释为：原来<span class="math inline">\(n\)</span>占了一位，但根据位数大小要多占<span class="math inline">\(n-10^i\)</span>位（二位数多占1位，三位数再多占一位，如此下去）</p></li><li><p>而一个<span class="math inline">\(k\)</span>位数在序列中对应的位置区间应该为<span class="math inline">\((\sum_{i=0}^{k-1}(i+1)\times 9\times10^i,\sum_{i=0}^{k}(i+1)\times 9\times10^i]\)</span>（<span class="math inline">\(i\)</span>位数有<span class="math inline">\(9\times10^i\)</span>个）</p></li><li><p>我们首先根据区间规律对<span class="math inline">\(n\)</span>的位数进行判断，与此同时，我们可以计算（1）式中需要减去的部分，记为<span class="math inline">\(offset\)</span></p></li><li><p>之后，我们可以根据（1）式计算出实际的数字<span class="math inline">\(num=(n+offset-1)/digit\)</span>和对应的位数（减1是为了让余数落在正确的范围内），最后利用整数转字符串函数取出对应位置的数即可</p></li><li><p>注意：判断范围时区间边界会超过int，且计算实际数字时也会超过，要用long long</p></li></ul><p>数学2</p><ul><li>根据上面的区间规律，我们可以边判断实际数字的位数，边减去区间左边界，这样就可以得到实际数字在某个位数区间内的偏移量<span class="math inline">\(offset\)</span>，那么实际数字也可以由<span class="math inline">\(num=(10^{digit}+offset-1)/digit\)</span>得到，余数也同理可得（具体到位数后，就可以均分了）</li></ul><p><strong>357. 计算各个位数不同的数字个数</strong></p><p>数学</p><ul><li>排列组合：从高位开始考虑，最高位只有9种可能，其他位的可能数从9开始递减，若只有1位数，则有10种可能</li><li>若n超过10，只需计算到n=10即可</li></ul><h3 id="day-42">Day 42</h3><p><strong>492. 构造矩形</strong></p><p>数学</p><ul><li>按照要求，需要求出相距最小的因数对</li><li>从<span class="math inline">\(\sqrt{n}\)</span>开始向下搜索可以整除的数即为宽度，商为长度（不向上搜索的原因是，开方是向下取整的，商和除数之间的大小关系不能严格保证）</li></ul><p><strong>507. 完美数</strong></p><p>数学</p><ul><li>统计因数即可，从1开始到<span class="math inline">\(\sqrt{n}\)</span>，找出所有因数对相加，最后减去数本身进行判断</li><li>注意：完全平方数的一个因数对为平方根，只需加一次，在循环判断内部要特判</li><li>实际上：int范围内只有5个完美数，即6\28\496\8128\33550336</li></ul><h3 id="day-43">Day 43</h3><p>*<strong>201. 数字范围按位与</strong></p><p>位运算</p><ul><li>考察两个二进制数的最长公共前缀，公共前缀的后一位必然不同。且对于m，这一位是0，对于n，这一位是1。</li><li>在由m累加至n的过程中，必然会经过01111...到10000...的变化，这使得最长公共前缀后的所有位数在最终结果中均为0</li><li>因此只需找到两个数的最长公共前缀，有两种方法<ul><li>两个数同时右移，直到相等，就找到了公共前缀，右移时记录移动位数，返回时将公共前缀左移</li><li>不断去除n最右边的1（<span class="math inline">\(n\&amp;(n-1)\)</span>），使得n小于等于m</li></ul></li></ul><p>*<strong>371. 两整数之和</strong></p><p>位运算</p><ul><li>先做无进位的加法（异或）</li><li>再求进位（与，左移1位）</li><li>若进位不为0，则一直做无进位加法结果与进位的“加法”，直到进位为0</li><li>不要试图模拟全加器！！！</li><li>注意负数作为加数时，移位是有符号的，因此要使用unsigned最终转换为int</li></ul><h3 id="day-44">Day 44</h3><p><strong>50. Pow(x, n)</strong></p><p>快速幂</p><ul><li>由于指数可能是负数，所以要特殊判断</li><li>快速幂：将指数看做二进制，每次循环判断当前指数位是否为1，若为1则乘上当前幂次。每次循环倍增底数，以符合二进制位数的规律。</li></ul><p><strong>136. 只出现一次的数字</strong></p><p>位运算</p><ul><li>将每个数异或起来，最终结果就是只出现一次的数（其他都成对异或为0了）</li></ul><h3 id="day-45">Day 45</h3><p><strong>217. 存在重复元素</strong></p><p>Hash</p><ul><li>遍历数组，用hash表记录元素数量即可</li></ul><p><strong>202. 快乐数</strong></p><p>Hash</p><ul><li>一个数在处理过程中有三种趋势：1）最终为1，2）最终循环，3）最终无穷大</li><li>观察每一个数量级的最大数，发现当位数超过4位后，每次计算会导致位数减少1，直到3位。因此第三种情况不存在，一旦某数在计算过程中曾经出现，则意味着循环。</li><li>在计算过程中，使用Hash表记录曾经出现过的元素，若某次计算重复，则返回false，否则最终必为1（？）</li></ul><p>双指针（快慢）</p><ul><li>计算过程构成了一个链表，需要判断链表中是否有环</li><li>构造两个“指针”，一个每次走1步，一个每次走2步（计算next函数的循环调用）</li><li>每次循环检查，快指针是否为1（先到1）或快慢指针相遇（有环）</li></ul><h3 id="day-46">Day 46</h3><p><strong>290. 单词规律</strong></p><p>Hash</p><ul><li>维护两个hash表（要求一一对应），使用stringstream来获取单词</li><li>失败条件：长度不相等或不能一一对应</li><li>长度判断可以使用stringstream的输入返回结果（成功or失败）</li></ul><p><strong>205. 同构字符串</strong></p><p>Hash</p><ul><li>和上题一致，维护两个hash表，判断是否一一对应即可</li><li>不需判断长度，假定已经相等</li></ul><p>字符串</p><ul><li>使用find函数，找出每一个字符在字符串中第一次出现的位置，这样就将字符映射到同一个集合</li><li>若结果不相同，则不能替换</li></ul><h3 id="day-47">Day 47</h3><p><strong>500. 键盘行</strong></p><p>Hash1</p><ul><li>为字母-行数建立map，遍历判断即可</li><li>注意大小写转换</li></ul><p>Hash2</p><ul><li>打表：字母对应的行数</li><li>遍历，转换至小写，判断单词所有字符是否在同一行即可</li></ul><p>*<strong>138. 复制带随机指针的链表</strong></p><p>Hash</p><ul><li>由于随机指针指向的节点位置不定、可前可后，因此按照正常顺序遍历拷贝时，可能随机指针指向的节点已经复制了一份。因此需要一个Hash表记录原链表节点和新链表节点之间的对应关系。</li><li>由于链表没有头结点，我们先对第一个节点（若存在）进行处理。先复制一个新的节点添加到Hash表中，再检查随机指针是否为空。若不为空，检查是否出现在Hash表中，若出现，则直接设置新的随机指针，否则需要复制一个节点，并将其添加到Hash表中。</li><li>循环中的操作和头结点相似，先检查当前节点是否存在，并设置prev指针的next指针。随后再检查随机指针，进行对应操作。</li></ul><p>链表</p><ul><li>使用Hash表的方法时空复杂度均不是最优。有一种想法：用节点与节点之间的指针链接代替Hash表中的对应关系。</li><li>首先遍历链表，为每个节点复制一个新节点插入在它后面。</li><li>其次，会发现新加入的节点随机指针应该指向的位置，是原节点随机指针（若不为空）指向的节点的下一个节点，再遍历一次设置随机指针。</li><li>最后，需要将原链表和新链表剥离，可以引入一个头结点来方便处理（注意保护原链表结构）</li></ul><h3 id="day-48">Day 48</h3><p><strong>1. 两数之和</strong></p><p>Hash</p><ul><li>将数组的值作为key，下标作为value储存在Hash表中</li><li>遍历数组，若<span class="math inline">\(target-nums[i]\)</span>存在于Hash表中，取出它的value，与当前下标一起返回</li><li>更简洁的方法：不需要先建立Hash表再遍历数组，遍历时还需判断是否为本身，直接遍历数组，先检查<span class="math inline">\(target-nums[i]\)</span>是否存在，若存在直接返回，每次添加当前元素进入Hash表就不必检查是否为本身</li></ul><p>*<strong>219. 存在重复元素 II</strong></p><p>Hash</p><ul><li>设计一个Hash表，key为数组中元素的值，value为最新的索引值</li><li>遍历数组，若当前元素在Hash表中存在，则判断它的索引与最近索引的距离是否不超过k，并更新最新索引值。若不存在，则加入Hash表。</li></ul><p>Hash+滑动窗口</p><ul><li>由于需要限制两相同元素之间距离不超过k，则维护一个大小为k的Hash表（也是大小为k的滑动窗口）</li><li>遍历数组，若能在Hash表中找到当前元素，说明当前元素有相同元素在k大小的滑动窗口内，它们之间的距离不会超过k（考虑边界情况也是如此），返回true。每次更新or添加当前元素和对应下标，若Hash表的大小超过k，则删去最老的那个元素，即<span class="math inline">\(nums[i-k]\)</span></li></ul><h3 id="day-49">Day 49</h3><p><strong>594. 最长和谐子序列</strong></p><p>Hash</p><ul><li>这里求的是子序列的长度，不必要求元素连续，求出的子序列应该只有两种元素x和x+1</li><li>可以先建立Hash表，统计不同元素的个数，再遍历数组，以当前元素为最小值，找出最大值的个数和最小值的个数相加，不断更新即可</li><li>可以只遍历数组一次，对每个元素，先更新Hash表中的统计，分别计算x和x-1的个数和&amp;x和x+1的个数进行最大值更新（代表以当前元素为末尾的和谐子序列的长度最大值）</li></ul><p>*<strong>599. 两个列表的最小索引总和</strong></p><p>Hash</p><ul><li>需要求两个数组的交集，并找出他们交集元素中索引和最小的几个元素</li><li>先对第一个列表建立Hash表，遍历第二个列表，若当前元素已经存在于Hash表中：<ul><li>若索引和小于当前最小结果，清空返回元素列表，加入新的元素，并更新最小索引和</li><li>若相等，则加入新的元素</li></ul></li><li>注意这里对最小值有多个的元素的处理</li></ul><h3 id="day-50">Day 50</h3><p>*<strong>554. 砖墙</strong></p><p>暴力</p><ul><li>计算墙的宽度，对宽度进行列遍历</li><li>检查当前遍历是否穿过了某一行的砖，记录当前列穿过的每一行的砖的下标，统计穿过的砖数</li><li>最后统计最小穿过的砖数</li><li>超时</li></ul><p>Hash</p><ul><li>转换角度：统计每个宽度值下，砖缝的个数，然后穿过那个拥有最多砖缝的宽度即可</li><li>对每一行、每一块砖进行遍历，计算当前砖缝所在的宽度，并更新Hash表中对应宽度的砖缝个数（不用统计最后一个砖，由于宽度为0的位置和最大宽度位置的砖缝都不能记录在内）</li><li>遍历Hash表，找到最大砖缝个数，返回高度-最大砖缝个数即为答案</li></ul><p>*<strong>560. 和为K的子数组</strong></p><p>Hash1+前缀和</p><ul><li>先计算前缀和，由于数组里可能包含非正数，所以前缀和数组中可能有重复元素</li><li>以前缀和为key，对应的所有下标为value建立Hash表</li><li>遍历前缀和数组，由于<span class="math inline">\(pre[j]-pre[i]=k\)</span>那么对于每个<span class="math inline">\(pre[i]\)</span>只需要找<span class="math inline">\(pre[j]=pre[i]+k\&amp;\&amp;j&gt;i\)</span>统计个数即可</li><li>超时</li></ul><p>Hash2+前缀和</p><ul><li>观察上面一种情况，最后统计时我们在下标顺序的限制下找Hash表中的项，从等式的另外一方来看对于每个<span class="math inline">\(pre[j]\)</span>，只需要统计它前面下标（<span class="math inline">\(i&lt;j\)</span>）的、符合要求的<span class="math inline">\(pre[i]=pre[j]-k\)</span>个数即可</li><li>那么我们完全不必要先计算前缀和，再建立复杂的Hash表，计算前缀和的同时、就可以统计结果</li><li>我们只需要建立Hash表，边计算当前的前缀和，边利用Hash表中记录的、在此索引之前的前缀和信息统计即可，统计完毕后更新Hash表中当前前缀和的信息即可</li></ul><h3 id="day-51">Day 51</h3><p>*<strong>523. 连续的子数组和</strong></p><p>Hash+前缀和</p><ul><li>建立Hash表，key为余数，value为第一个余数为key的前缀和位置</li><li>一边计算前缀和，一边查找余数是否存在，若存在，判断距离是否大于1，若不存在，记录索引（注意是i+1！）</li><li>需要对k=0的情况特殊处理<ul><li>单独分支，遍历数组，查看是否有相邻的2个及以上的0</li><li>循环内分支统计连续0个数，超过1即可返回</li><li>在原代码结构上，判断k是否为0，若k为0则Hash表key的含义直接为前缀和，查找也查找前缀和</li></ul></li></ul><p>*<strong>525. 连续数组</strong></p><p>Hash+前缀和</p><ul><li>根据01序列的前缀和特点可知，某子数组的和即为其中1的个数，根据题意只需要找到<span class="math inline">\(2\times(pre[j]-pre[i])=j-i\)</span>的区间即可，但涉及到对区间的枚举，使用Hash表也难以确立对应关系</li><li>01序列还有另一种前缀和，即差分前缀和，将0看作-1。这样前缀和中两个相等值之间的区间内和为0，即01数量相等</li><li>我们可以为这样的前缀和建立Hash表，key为前缀和，value为第一次出现这个前缀和的位置</li><li>遍历计算差分前缀和，查找Hash表，若存在key，更新最大长度，否则记录索引（注意是i+1！）</li></ul><h3 id="day-52">Day 52</h3><p>*<strong>633. 平方数之和</strong></p><p>二分法</p><ul><li>枚举<span class="math inline">\(a\)</span>，在<span class="math inline">\(c-a^2\ge 0\)</span>的情况下，在<span class="math inline">\([0,c-a^2]\)</span>范围内二分查找<span class="math inline">\(b\)</span>使得<span class="math inline">\(b^2=c-a^2\)</span></li><li>也可以将二分查找替换为开方</li></ul><p>数学</p><ul><li>费马平方和定理：一个非负整数 <span class="math inline">\(c\)</span> 能够表示为两个整数的平方和，当且仅当 <span class="math inline">\(c\)</span> 的所有形如 <span class="math inline">\(4k+3\)</span> 的质因子的幂次均为偶数。</li><li>分解质因数，对形如<span class="math inline">\(4k+3\)</span> 的质因子，判断是否有偶数个</li></ul><p>双指针法</p><ul><li>左指针初始为0，右指针初始为<span class="math inline">\(\sqrt{c}\)</span></li><li>若<span class="math inline">\(l^2+r^2&lt;c\)</span>则右移左指针</li><li>若<span class="math inline">\(l^2+r^2&gt;c\)</span>则左移右指针</li><li>否则返回true</li><li>注意判断时防止溢出，可对等式or不等式进行变形</li></ul><p>*<strong>128. 最长连续序列</strong></p><p>Hash1</p><ul><li>由于不要求顺序，则可以考虑Hash表记录已存在的连续序列信息，若当前元素已经在某序列中，则不必再遍历统计一次</li><li>遍历列表，建立一个Hash表，key为元素值，value为是否在某连续序列中</li><li>再次遍历，判断当前元素是否在连续序列中，若不在，则进行遍历、统计长度、更新最大长度，同时要设置序列上元素对应的value为true（但如果不在连续序列中，却是孤立元素，最后循环外不必设置它为true，否则需要设置）</li></ul><p>Hash2</p><ul><li>上面的方法超时，观察不必继续计算的条件，发现我们只需要从某连续序列最小的那个元素开始计算长度即可，即判断当前元素n的前驱n-1是否在Hash表中，若不在，则说明是当前最小，可以开始统计长度</li></ul><p>Hash3</p><ul><li>一遍遍历的方法，设Hash表的key为元素值，value为这个元素值所处的连续序列的长度</li><li>遍历时，先找前驱、后继是否存在，若不存在，左or右长度置为0，否则可以取出左区间和右区间的长度，更新当前元素的value值、最大长度值以及左、右边界元素在Hash表中对应的长度值</li><li>为何只需更新边界值？每次遍历到的元素必然是没有出现在任何连续序列中的（加上了去重条件），它的作用要么是链接一个or两个连续序列，要么孤立。而链接的已经连续的序列中的非边界元素，之后遇到也不会处理（已经出现、已经属于某序列），这时，只有左右边界元素是有作用的（用于合并），因此不必关心连续序列中的非边界元素的Hash表信息。</li></ul><h3 id="day-53">Day 53</h3><p>*<strong>532. 数组中的 k-diff 数对</strong></p><p>Hash</p><ul><li>先建立Hash表，key为元素，value为元素个数</li><li>遍历Hash表，若k为0，只需统计个数多于1的元素个数即可，否则寻找<span class="math inline">\(n+k\)</span>或<span class="math inline">\(n-k\)</span>即可（避免重复统计）</li></ul><p>*<strong>203. 移除链表元素</strong></p><p>链表</p><ul><li>先为链表设置伪头，设prev初始为fake、cur为head</li><li>遍历链表，直到cur为空<ul><li>若当前cur值为要删去的值，那么将prev的下一个节点设置为cur的下一个，删除cur并将cur移动至prev的下一个</li><li>这时应该移动两个指针，但cur的位置可能在删除时已经改变，有三种情况：1）为空，2）非空但需要删除，3）非空且不需要删除，对于3）可以将prev、cur前移，但1）不能前移，回到while判断时直接退出；2）不需要移动，下一次继续删除cur</li></ul></li><li>由于head可能被删除，需要重置head为fake的下一个，并删除fake</li><li>还有一种解法：遍历时若需要删除，则将prev的下一个设置为cur的下一个，否则prev设置为cur，而cur每次设置完毕后前移。若有删除节点cur，则应该先保存，移动后再删除</li></ul><h3 id="day-54">Day 54</h3><p>*<strong>237. 删除链表中的节点</strong></p><p>链表</p><ul><li>指定要删除的节点，但是不给出链表头，也就无法遍历、删除</li><li>由于给定节点必然存在、且不是末尾，那么必然有下一个节点</li><li>既然无法获得前一个节点，但又要删除一个，只能删除下一个，这时，将下一个节点的值前移至本节点，然后绕开下一个节点，删除它即可</li></ul><p><strong>19. 删除链表的倒数第N个节点</strong></p><ul><li>先设置伪头，并将一个指针从伪头开始移动N次</li><li>将另一个指针初始化为伪头，和之前的指针一起移动，直到前面的指针到达最后一个非空节点（<code>ptr-&gt;next==NULL</code>）</li><li>这时，后面的节点必然在倒数第N+1个节点处，则可以绕过下一个元素并删除之，最后勿忘重新设置head指针（有可能被删除而失效）</li></ul><h3 id="day-55">Day 55</h3><p>*<strong>160. 相交链表</strong></p><p>链表1</p><ul><li>如果两个链表在某处相交，那么它们在此后都共用一个链表</li><li>若要找到交点，我们可以先调整指针开始移动的位置，观察可知，只需要将遍历长链表的指针前移，使得它和遍历短链表的指针距离相交点的距离相同即可</li><li>长链表指针需要前移的位置是两个链表的长度差，因此我们首先计算两个链表的长度（注意：两个链表都不能为空）</li><li>然后找到长度差、调整指针初始位置</li><li>调整完毕后，两个指针一起前移，直到相等，但有可能不相交，那么两者必然都到达NULL且之前没有交点，返回NULL</li></ul><p>链表2</p><ul><li>由方法1可知，问题的关键是使两个指针位于“距离交点orNULL相等的位置上”</li><li>既然交点是共享段链表的起始点，那么距离交点相等位置也是距离链表尾相等位置</li><li>我们让长链表指针和短链表指针同时前进，并且规定当指针到达NULL时回到对方的开头<ul><li>那么短链表指针必然先到达长链表头（走了m步）</li><li>当长链表指针到达短链表头时，它们都走了长链表的长度（n），这时，它们距离链表尾部的长度均为短链表的长度（m），即短链表指针在长链表上又走了（n-m）步，长度差被消除了</li><li>这时再让两个指针同时向前移动，必然会相等（可能是NULL），返回其中一个即可</li></ul></li><li>总的来说：m+c+n+c=n+c+m+c</li></ul><p><strong>430. 扁平化多级双向链表</strong></p><p>链表</p><ul><li>从头开始遍历，若当前节点有子链表，则使用一个指针找到子链表的末尾，并将子链表插入主链表中，置当前节点的子链表指针为空，遍历主链表中的下一个即可（注意插入时，判断下一个是否为空，若不为空才设置下一个的prev为本节点）</li></ul><p>DFS（迭代）</p><ul><li>将next指针看做右子树、child指针看做左子树，实际上是先序遍历、输出双链表</li><li>用迭代法DFS比递归法更容易处理链表的链接，首先设置伪头为prev指针，将head入栈，开始循环直到栈空<ul><li>出栈，并链接prev和当前节点</li><li>若有右子树，入栈，若有左子树，入栈、设置child指针为空（先序遍历）</li><li>prev前移至当前节点</li></ul></li></ul><p>DFS（递归）</p><ul><li>仍然是看做二叉树、先序遍历，但需要在递归的过程中改变链表的链接</li><li>设递归函数第一个参数为扁平化后需要链接的位置，第二个参数为需要扁平化的链表的第一个节点</li><li>递归函数的作用为扁平化链表、链接至正确位置、返回扁平化后的最后一个节点</li><li>递归基础为，当不存在需要扁平化的列表时，返回需要链接的位置</li><li>在一次函数调用中，首先将需要扁平化的列表链入结果链表，然后递归左子树、得到结果链表末尾的最新位置、置child指针为空，再递归右子树，返回结果</li><li>注意，递归左子树时，可能将右子树的指针改写，因此需要在递归前保存</li></ul><h3 id="day-56">Day 56</h3><p><strong>389. 找不同</strong></p><p>异或</p><ul><li>同<strong>136</strong></li></ul><p>*<strong>206. 反转链表</strong></p><p>链表+双指针1</p><ul><li>初始化cur指针为head，prev指针为空（cur之前）</li><li>开始遍历直到cur为空，将cur的next指针指向prev，完成翻转，移动prev和cur指针至下一个位置（prev到cur，cur到预先保存的原来的下一个位置）</li></ul><p>链表+双指针2</p><ul><li>将head-&gt;next指针指向还未翻转的链表的第一个元素（head也是最终的末尾），而cur指向已翻转链表的头结点</li><li>初始时，cur在head处，开始遍历直到不再有未翻转的链表（head-&gt;next指针为空）<ul><li>将head-&gt;next节点的next指针设为cur，完成翻转</li><li>并移动cur至head-&gt;next节点、head-&gt;next指针至原来的下一个节点（预先保存），以维持指针定义不变</li></ul></li></ul><p>递归</p><ul><li>一直递归到最后一个节点或空节点，返回这个节点作为翻转链表的头结点</li><li>每层递归的head参数，均为未翻转链表的倒数第二个元素，从head-&gt;next开始的链表已经翻转</li><li>那么只需要将head-&gt;next节点的的next指针设置为head，并将head的next指针置空，就完成了当前的局部翻转，返回</li></ul><h3 id="day-57">Day 57</h3><p><strong>61. 旋转链表</strong></p><p>链表1</p><ul><li>观察可知，我们需要将倒数第k个元素开始的链表放在前面链表之前，那么我们先找到倒数第k+1节点，然后将它的下一个节点设置为新的头节点，然后将它的next指针置空，在找倒数第k+1节点的过程中，快指针到达最后一个节点，将它的下一个节点设置为原头节点，这样就完成了旋转</li><li>但需要注意特殊情况<ul><li>节点数少于2个（0or1）：不需要处理，直接返回</li><li>k的原始值为0：不需要处理，直接返回</li><li>k大于链表长度：先计算链表长度、取模、判断是否为0，再做旋转</li></ul></li></ul><p>链表2</p><ul><li>按照环状链表的思想，先将链表连接成环（顺便统计长度）</li><li>在环上找到第<span class="math inline">\(len-(k\%len)\)</span>个元素作为新的尾节点，而它的下一个为新的头结点</li></ul><p><strong>24. 两两交换链表中的节点</strong></p><p>链表</p><ul><li>三指针法，首先设置伪头，初始化指针prev为fake，cur为head，succ为head的下一个节点（保证长度大于2的情况下）</li><li>开始遍历，在cur和succ都不为空的情况下，修改三个指针的next指针，然后移动三个指针至合适位置以保持定义一致（注意指针为空的情况，不能访问，需要特判）</li><li>最后返回fake的下一个节点即可</li><li>也可以只设置一个指针，在循环里取出另外两个指针</li></ul><h3 id="day-58">Day 58</h3><p><strong>1688. 比赛中的配对次数</strong></p><p>模拟1</p><ul><li>累计这轮的配对数，计算进入下一轮的队伍数，直到只剩1个队伍</li></ul><p>二叉树 or 模拟2</p><ul><li>考虑配对数和淘汰数的问题：每次配对都会淘汰1个队伍，最终只剩1个队伍，因此淘汰n-1个队伍，即配对n-1次</li><li>每次配对都对应二叉树上的一个二叉结构，每一层都是一轮比赛，总共有n个叶子节点（度为0），配对数是度为2的节点总数，根据二叉树性质n0=n2+1，返回n-1</li></ul><p>*<strong>746. 使用最小花费爬楼梯</strong></p><p>动态规划</p><ul><li>根据题意，从<span class="math inline">\(i\)</span>出发到达<span class="math inline">\(j\)</span>需要花费<span class="math inline">\(cost[i]\)</span>的体力，而一次跨越可以是1级楼梯也可以是2级</li><li>定义<span class="math inline">\(dp[i]\)</span>为到达<span class="math inline">\(i\)</span>的最小体力花费，阶梯顶的位置为<span class="math inline">\(n\)</span></li><li>转移方程：<span class="math inline">\(dp[i]=\min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])\)</span></li><li>初始状态：<span class="math inline">\(dp[0]=dp[1]=0\)</span>，可以选择从第0个或者第1个阶梯出发</li><li>可以使用滚动数组</li></ul><h3 id="day-59">Day 59</h3><p><strong>92. 反转链表 II</strong></p><p>链表</p><ul><li>由于是部分反转，所以需要记录反转部分之前的节点和反转部分的最后一个节点，这样才能接入链表</li><li>首先确保m不为n且链表长度大于2，设置一个伪头fake以便反转</li><li>先将prev移动至需要反转的部分的前一个节点，记录起来作为新的头；再将prev前移一位，此时的节点是反转部分反转后的最后一个节点，记录下来</li><li>设cur为prev的下一个节点，反转n-m次（参照<strong>206</strong>），最终prev处于反转部分的第一个节点，而cur处于反转部分后的第一个节点</li><li>将之前记录的节点和prev、cur进行正确链接，设置新的head，删除fake返回即可</li><li>反转时可以使用另一种双指针法，还可以进行递归，在<strong>206</strong>递归法的基础上，记录后继节点，找到开始反转的位置，递归翻转后需要链接后继节点</li></ul><p>*<strong>21. 合并两个有序链表</strong></p><p>链表（迭代）</p><ul><li>首先设置伪头，然后开始遍历两个链表，直到其中的一个为空</li><li>每次迭代对两个链表的指针的元素进行比较，将较小的一个链入，然后将对应指针前移，并将指向“结果链表”的指针前移（可以发现指向结果链表的指针总是在下一个需要链入的节点之后）</li><li>当循环结束，指向结果链表的指针处于最后一个节点处，若还有某个链表没有遍历完成，它所对应的指针正好在剩余部分的第一元素，直接链入结果链表即可</li><li>不需要特别判断空指针</li></ul><p>链表（递归）</p><ul><li>递归奠基：其中某个链表为空</li><li>递归：按照元素大小调用不同的函数链入当前节点</li><li>返回：已经合并好的链表的头结点</li></ul><h3 id="day-60">Day 60</h3><p><strong>141. 环形链表</strong></p><p>链表+快慢指针</p><ul><li>一个快指针每次走两步，一个慢指针一次走一步，若有环，则必然相遇</li><li>将两个指针都置于头结点，开始循环直到某个为空，移动快慢指针，注意快指针先移动一次然后判断是否为空，再移动</li><li>移动后判断在两个指针都不为空的情况下是否相等</li><li>为了简化条件判断，可以先检查链表长度是否大于1，然后慢指针在第一个节点，快指针在第二个（假设它们都从同一个虚拟头结点移动而来）循环直到两者相等，循环体中，先判断快指针是否为空以及它的下一个节点是否为空，若是则返回（快指针必然先到达空，若无环）然后再移动</li></ul><p><strong>83. 删除排序链表中的重复元素</strong></p><p>链表1</p><ul><li>边走边删：在链表仍然有两个节点的情况下，若当前节点和下一个节点数值相同，则跨过下一个节点并删除之</li><li>初始化指针指向头结点，循环直到剩下链表中节点数小于2个</li><li>若当前节点和下一节点元素相同，则跨过下一个节点，并删除它</li><li>否则说明当前节点下一个节点既是不同元素的节点，直接移动至下一个节点</li></ul><p>链表2</p><ul><li>一次性删除：每次用cur找到下一个不同元素的节点，然后删除之间的重复节点，再将prev链接至cur</li><li>设置prev指针为head，cur指针为head的下一个节点，循环直到cur到达NULL</li><li>先循环找到下一个不相同元素的节点，注意判断cur是否为空</li><li>删除prev和cur之间重复的元素并链接prev和cur</li><li>移动prev和cur指针（若可以）</li><li>常数较大</li></ul><h3 id="day-61">Day 61</h3><p><strong>86. 分隔链表</strong></p><p>链表+双指针</p><ul><li>考虑从原链表中剥离出放在前面的链表，然后再重新组合</li><li>保证链表长度大于1的情况下，为原链表和新链表设置伪头，然后用双指针开始遍历原链表</li><li>若当前节点的元素值小于x，那么需要链入新链表，则跨过当前节点，并将它链入新链表（但不需要移动前置指针，可能重复值）</li><li>否则将当前节点留在原链表中，需要将前置指针前移，表明不需要跨越</li><li>每次迭代都前移当前指针，直到它为空</li><li>最后在新链表的尾部链上原链表即可</li></ul><p>*<strong>234. 回文链表</strong></p><p>链表+快慢指针</p><ul><li>若需要常数空间复杂度，则不能使用栈或递归，需要考虑获得后半段链表，然后与前半段进行对比</li><li>可以使用快慢指针来找到链表的中点，慢指针一次走一个节点，快指针一次两个，当快指针不能继续前进时，慢指针到达中点（奇数长度）or中点右边（偶数长度）</li><li>由于需要判断回文，又是单链表，那么需要反转后半段链表，反转的起始位置为中点右边的节点（奇数长度需要忽略中点）</li><li>反转后半段后再进行比较即可</li></ul><p>栈</p><ul><li>先遍历链表，将节点元素入栈</li><li>再遍历链表，出栈的同时比较元素是否相等</li><li>可以稍作优化，在第一次遍历时记录链表长度，第二次遍历比较只需要遍历一半即可</li></ul><h3 id="day-62">Day 62</h3><p><strong>876. 链表的中间结点</strong></p><p>链表+快慢指针</p><ul><li>慢指针一次一步，快指针一次两步，待快指针不能进行两步移动，返回</li></ul><p><strong>1290. 二进制链表转整数</strong></p><p>链表</p><ul><li>链表从头到尾是二进制数从高位到低位，直接计算即可</li></ul><h3 id="day-63">Day 63</h3><p>*<strong>328. 奇偶链表</strong></p><p>链表1</p><ul><li>对长度大于2的链表进行操作，设置一个奇指针和记录奇数子链表末尾的指针，再为抽离出来的偶数子链表设置一个伪头和末尾指针</li><li>对于原链表进行遍历，使用奇数指针直到它不能进行两步移动<ul><li>先保存下一个偶数节点指针</li><li>当前奇数指针跨过偶数节点</li><li>将偶数节点链接到偶数子链表的末尾</li><li>记录奇数子链表的尾部</li><li>移动奇数指针和偶数子链表末尾指针</li></ul></li><li>若奇数指针不为空，说明真正的奇数子链表尾部在此处，否则尾部在之前的奇数指针</li><li>将偶数子链表链接到奇数子链表末尾，并将偶数子链表末尾的指针置为空，返回</li></ul><p>链表2</p><ul><li>保证头结点不为空，设置一个偶数头结点，并将奇偶指针分别指向对应的头结点</li><li>遍历链表，直到偶指针不能移动两步（移动过程中偶指针总在前）<ul><li>先将奇指针绕过下一个偶节点，并更新奇指针，这时奇指针在偶指针之后一个</li><li>再将偶指针绕过下一个奇节点（刚刚更新的奇指针），并更新偶指针，这时偶指针在奇指针之后一个</li></ul></li><li>循环结束后，奇指针恰好在最后一个奇数节点，直接进行链接即可</li></ul><p><strong>725. 分隔链表</strong></p><p>链表</p><ul><li>先找出链表的长度，计算每组应该放几个节点，再计算余数，为前面的每一组多放一个节点</li><li>开始填充k个位置，每一次记录这一段的开始节点，然后前进当前组应该放的节点数-1次，抵达本组最后一个节点退出循环</li><li>将开始节点填入数组，若当前还没有遍历完链表，就需要将当前组最后节点的next指针置空，然后向前进，到达下一组的开始节点</li><li>最后更新余数，即还需要多为每组分配的节点个数</li><li>注意：涉及到cur的时候都要判断是否为空，再进行操作</li></ul><h3 id="day-64">Day 64</h3><p><strong>817. 链表组件</strong></p><p>链表+Hash</p><ul><li>根据数组建立Hash表</li><li>内循环遍历链表，直到当前节点为空或值不在Hash表中，跳出内部循环，记为一个组件</li><li>内循环外，当前指针指向的节点值必然不在Hash表中，若非空，则可以继续向前一位</li><li>若没有进入内循环，则不必在外部增加组件数量</li><li>从另一个角度：只数组件的末尾数，一直连续找到在Hash表中的最长链的末尾，才累计一个组件（判断条件，当前节点值在Hash表中，但下一个节点为空或值不在Hash表中），这样只需要让指针一直前进即可</li></ul><p><strong>2. 两数相加</strong></p><p>链表</p><ul><li>建立一个伪头，方便新链表的生成</li><li>同时遍历两个链表，计算当前位的和及进位，创建新的节点，移动指针</li><li>当其中一个链表为空，则循环结束，进入另一个循环，计算较长链表的剩余位，流程类似第一个循环</li><li>若最终进位不为空，还需创建一个节点放置最高进位</li><li>也可以只写一个循环，判断当前指针是否为空，若为空，对于加数设为0，移动指针时先判断是否为空</li></ul><h3 id="day-65">Day 65</h3><p><strong>143. 重排链表</strong></p><p>链表</p><ul><li>寻找中点+反转链表+合并链表</li><li>根据题意，应该把链表后半段按照倒序插入到前半段中，若链表长度为奇数，则后半段指短的那一半</li><li>首先找到中点之前的那个节点保存，然后分别设置两个半链表的头部，并将中点前一个节点的next指针置空</li><li>反转后一半链表，并将反转后的链表合并到前一半链表中</li></ul><p>*<strong>142. 环形链表 II</strong></p><p>链表</p><ul><li>设环前链表长<span class="math inline">\(a\)</span>，双指针判断有环相遇时，慢指针走过长度<span class="math inline">\(b\)</span>，环的剩余长度为<span class="math inline">\(c\)</span></li><li>相遇时，慢指针走过的长度<span class="math inline">\(a+b\)</span>，快指针走过的长度<span class="math inline">\(a+b+n(b+c)=2(a+b)\)</span>，即<span class="math inline">\(a=c+(n-1)b\)</span></li><li>第一次相遇时，快指针只比慢指针快1圈，即<span class="math inline">\(n=1\)</span>，则只需要让一个指针回到链表头和相遇点指针一起前进直到相遇即可</li><li>实现时，可以使用do-while循环，将返回空值控制在循环中</li></ul><h3 id="day-66">Day 66</h3><p><strong>1669. 合并两个链表</strong></p><p>链表</p><ul><li>找到删除节点的前一个节点，然后开始删除节点，到达删除节点之后的第一个节点</li><li>将另一个链表链入这两个位置即可</li></ul><p><strong>20. 有效的括号</strong></p><p>栈</p><ul><li>根据题意，三种括号必须正确匹配，使用栈</li><li>对于字符串中的每一个字符<ul><li>若栈空或为左括号，则入栈</li><li>若为右括号，则与栈顶字符进行匹配，若匹配成功则出栈，否则匹配失败</li></ul></li><li>最后检查栈是否为空，若为空则匹配成功</li></ul><h3 id="day-67">Day 67</h3><p>*<strong>26. 删除排序数组中的重复项</strong></p><p>双指针</p><ul><li>左指针指向维护好的、无重复的数组的最后一个元素（初始化为0）</li><li>右指针寻找下一个与最后一个元素不同的元素（初始化为1）</li><li>实现时，每次循环先判断左右指针元素是否相同，若不同则需要更新左指针并赋值；每次循环右指针都右移</li></ul><p>*<strong>55. 跳跃游戏</strong></p><p>贪心</p><ul><li>若一个位置能到达，那么它左边的所有位置都可以到达，那么只需要维护能到达的最右端位置即可</li><li>设能到达的最右位置初始为0，遍历数组<ul><li>检查当前位置是否可以到达，即是否小于等于最左位置，若不能到达则返回false</li><li>更新最右能到达位置</li></ul></li><li>若循环中没有返还，说明能更新到最后一个位置，也意味着能到达最后一个位置（实际上，循环中更新最右能到达位置之后就可判断是否覆盖最后一个位置）</li></ul><h3 id="day-68">Day 68</h3><p>*<strong>88. 合并两个有序数组</strong></p><p>双指针1</p><ul><li>归并排序中的归并方法，用两个指针指向两个排好序的子数组，将它们合并到一个辅助数组中，在复制到目标数组中</li><li>注意到合并的目标数组为其中的一个子数组，可以先将这个数组中的内容复制出来，然后合并到这个数组，可以节省空间、降低常数</li></ul><p>双指针2</p><ul><li>由于要合并到的目标数组是其中的一个子数组，且有空闲位置，可以考虑利用这样的位置</li><li>那么我们从末尾开始合并，改变循环中判断的不等号方向，即从大到小合并</li><li>初始时，两个指针分别指向两个子数组的真正末尾，另一个结果指针指向合并后的末尾，然后进行合并</li><li>正确性：保证结果指针不会超过第一个指针（不会覆盖未合并的值）<ul><li>如果当前合并的是第一个指针的值，那么它们之间的距离不会改变</li><li>否则，它们之间的距离会减一，但初始时他们的距离为n，极端情况下（第二个数组连续、全部复制），只会重合，而不会超过</li></ul></li></ul><p>*<strong>198. 打家劫舍</strong></p><p>动态规划</p><ul><li><p>设<span class="math inline">\(dp[k]\)</span>为偷前<span class="math inline">\(k(0\cdots n-1)\)</span>家的最大收益</p></li><li><p>转移方程：对于<span class="math inline">\(dp[k]\)</span>，如果偷<span class="math inline">\(k\)</span>，那么不能偷<span class="math inline">\(k-1\)</span>；如果不偷<span class="math inline">\(k\)</span>，那么收益和<span class="math inline">\(dp[k-1]\)</span>一样 <span class="math display">\[  dp[k]=\max(nums[k] + dp[k-2],dp[k-1])\quad(k&gt;1)  \]</span></p></li><li><p>初始状态：<span class="math inline">\(dp[0]=nums[0]\)</span>，<span class="math inline">\(dp[1]=\max(nums[0],nums[1])\)</span></p></li><li><p>注意：先判断数组长度是否大于1，再递推；若想节省空间，滚动数组，设置两个变量，依次更新</p></li></ul><h3 id="day-69">Day 69</h3><p><strong>387. 字符串中的第一个唯一字符</strong></p><p>Hash1</p><ul><li>先遍历一遍字符串，建立Hash表，若一个字符出现了第二次，将它对应的值设置为-1</li><li>再遍历一遍Hash表，找到最小的那个非负索引返回，若找不到则返回-1</li></ul><p>Hash2</p><ul><li>由于是字符Hash，直接统计字符出现的个数</li><li>再遍历一遍，第一个遇到的、字符出现个数为1的下标即返回</li></ul><p><strong>344. 反转字符串</strong></p><p>双指针</p><ul><li>一头一尾两个指针，交换至相遇or错过</li></ul><h3 id="day-70">Day 70</h3><p><strong>125. 验证回文串</strong></p><p>字符串+双指针</p><ul><li>由于字符串中存在非字母和数字，因此需要去掉这些字符再判断回文</li><li>可以新建一个字符串，然后遍历原字符串，将转换至小写的字母和数字放入新字符串，对新的字符串判断即可</li><li>也可以原地判断，循环中，左右指针分别在不相遇的情况下跳过无关字符，然后转换大小写判断</li></ul><p><strong>412. Fizz Buzz</strong></p><p>字符串</p><ul><li>按照题意判断、生成数组即可</li><li>优化的方法：先判断是否被3整除、被5整除，根据判断结果先后生成对应字符串，可以节省计算</li></ul><h3 id="day-71">Day 71</h3><p>*<strong>134. 加油站</strong></p><p>贪心?</p><ul><li>设<span class="math inline">\(y\)</span>是从<span class="math inline">\(x\)</span>出发能到达的最远的位置，说明<span class="math inline">\(\sum_{i=x}^ygas[i]&lt;\sum_{i=x}^ycost[i]\)</span>且<span class="math inline">\(\sum_{i=x}^jgas[i]\ge \sum_{i=x}^jcost[i](\forall\, j\in[x,y))\)</span></li><li>对于<span class="math inline">\([x,y]\)</span>之间的任意一个点<span class="math inline">\(z\)</span>，根据上面的不等式和累加关系<span class="math inline">\(\sum_{i=z}^ygas[i]&lt;\sum_{i=z}^ycost[i]\)</span>说明<span class="math inline">\(z\)</span>最远也只能到达<span class="math inline">\(y\)</span></li><li>那么从0开始检查，若能环绕一周，则为0，否则从第一个不能到达的加油站开始检查</li></ul><p>贪心</p><ul><li>从下标0处出发，累计计算到达下一位置时的剩余油量（当前加油-路途损耗），最后得到从0出发回到0的累计剩余油量曲线</li><li>若从任一点出发，要回到此点，必须保证从这点开始生成的累计剩余油量曲线全部大于等于0</li><li>这样的曲线可以由0-0累计剩余油量曲线生成<ul><li>以最低点为原点（贪心）</li><li>将最低点左边的曲线平移到最右边链接起来</li></ul></li><li>原0-0曲线最右端的值设为<span class="math inline">\(d\)</span>，任意生成曲线最右端的值也为<span class="math inline">\(d\)</span>（绕一圈绝对耗油量相同），要保证累计剩余油量曲线全部大于等于0，则要求<span class="math inline">\(d\ge 0\)</span></li><li>实现时，累计计算绝对油量，找到最小值和对应下标，返回时检查最终绝对油量是否非负</li><li>若非负，返回最小值下标的“下一个”（每一个点的值意为从这个点加油后到下一个点加油前的累计耗油量）</li><li>返回这样的值，将绝对耗油最大的一次行走放在最后，尽可能累计油量，体现贪心思想</li></ul><p>*<strong>169. 多数元素</strong></p><p>Hash</p><ul><li>统计元素个数生成Hash表</li><li>遍历Hash表，找到多数元素</li></ul><p>排序</p><ul><li>排序数组，取中间元素</li><li>可以使用堆排序来降低空间复杂度</li></ul><p>摩尔投票法</p><ul><li>将候选人初始化为第一个元素，票数初始化为1</li><li>遍历数组，若遇到与候选人相同的元素，则增加一票，否则减少一票，若票数为0，则更换候选人为当前元素，最后的候选人就是多数元素</li><li>由于多数元素的个数<span class="math inline">\(&gt;\lfloor n/2\rfloor\)</span>，那么其他元素的总个数必然<span class="math inline">\(\le\lfloor n/2\rfloor\)</span>，他们之间的差值至少为1</li><li>进行摩尔投票法，不同元素互相抵消，在多数元素的角度上，抵消到最后多数元素必然剩余至少一个元素（极端情况，均匀分布）</li></ul><h3 id="day-72">Day 72</h3><p><strong>605. 种花问题</strong></p><p>贪心1</p><ul><li>贪心思想：按照规则，如果当前位置可以种花，不种不可能得到更优解</li><li>可以发现，一段连续0可以种植的花数为<span class="math inline">\((\#0-1)/2\)</span></li><li>若连续0在最左或最右边界，则需要特别判断<ul><li>为了不修改循环体，设统计连续0的变量初始为1，并且在循环结束后补1个0计算总数</li><li>也可以在末尾添加01达到目的</li></ul></li></ul><p>贪心2</p><ul><li>也可以采用跳格子的方法</li><li>若当前位置是1，则当前不能种、下一个也不能种，跳2格</li><li>若当前位置是0，则前一个位置必为0（必由1跳来，而1的下一个不能为0）<ul><li>若下一个位置为0，则种花，并跳2格（相当于当前为1）</li><li>若下一个位置为1，则跳3格</li></ul></li></ul><p>贪心3</p><ul><li>能种花的条件是<ul><li>当前为0</li><li>左边为0，或为左边界</li><li>右边为0，或为右边界</li></ul></li><li>能种则种</li></ul><p>*<strong>455. 分发饼干</strong></p><p>贪心</p><ul><li>贪心思想：胃口小的吃小的、胃口大的吃大的</li><li>先对胃口数组和饼干数组排序，对于第<span class="math inline">\(i\)</span>个孩子和对应的满足<span class="math inline">\(g_i\le s_j\)</span>的最小饼干<span class="math inline">\(j\)</span><ul><li>若下一个孩子也可以吃这块饼干，将这块饼干给他，不会导致更多的孩子吃到饼干（要么后面的饼干给<span class="math inline">\(i\)</span>，要么没有饼干了）</li><li>若把下一块饼干给<span class="math inline">\(i\)</span>（一定满足），而把<span class="math inline">\(j\)</span>给下一个孩子。若他能被满足，那么和上一种情况一样；否则，浪费了一块饼干</li></ul></li><li>遍历每一个孩子，找到能满足他的、未被分配的最小饼干，分配给他（由于已经排序，所以只用遍历数组一次即可），若找不到，则后面的孩子也不能被满足，可以退出循环</li></ul><p><strong>122. 买卖股票的最佳时机 II</strong></p><p>贪心</p><ul><li>由于股票购买次数无限制，但不能重叠交易，因此需要找到一个左开右闭区间集合，使得利润最大</li><li>可以发现，一个区间<span class="math inline">\((l,r]\)</span>所获得的利润等于<span class="math inline">\(\sum_{i=l}^{r-1}(a[i+1]-a[i])\)</span></li><li>贪心思想：购买每个上升区间，也就是购买所有上升的、长度为1的子区间（实现时方便）</li><li>顺序遍历，统计所有前后之差为正的相邻元素对即可</li></ul><p>*动态规划</p><ul><li>设<span class="math inline">\(dp[i][0]\)</span>为第<span class="math inline">\(i\)</span>天交易完成后不持有股票的最大收益，<span class="math inline">\(dp[i][1]\)</span>为第<span class="math inline">\(i\)</span>天交易完成后持有股票的最大收益</li><li>转移方程：<ul><li>若第<span class="math inline">\(i\)</span>天结束交易以后没有股票，那么前一天没有或者当天卖出<span class="math inline">\(dp[i][0]=\max\{dp[i-1][0],dp[i-1][1]+price[i]\}\)</span></li><li>若第<span class="math inline">\(i\)</span>天结束交易以后有股票，那么前一天有或者当天买入<span class="math inline">\(dp[i][0]=\max\{dp[i-1][1],dp[i-1][0]-price[i]\}\)</span></li></ul></li><li>初始状态：<span class="math inline">\(dp[0][0]=0,dp[0][1]=-price[0]\)</span></li><li>返回：由于最后一天不持有股票肯定收益更高，返回<span class="math inline">\(dp[n-1][0]\)</span></li></ul><h3 id="day-73">Day 73</h3><p><strong>860. 柠檬水找零</strong></p><p>贪心</p><ul><li>若收到5元，则收下</li><li>若收到10元，收10元退5元，不能退则失败</li><li>若收到20元，优先退10元+5元，迫不得已退3个5元，否则失败</li><li>贪心思想：5元纸币用处更大，所以尽量退回10元的钱</li></ul><p><strong>1217. 玩筹码</strong></p><p>贪心</p><ul><li>贪心思想：由于移动2格花费为0，因此尽量选择这样的方法</li><li>可以发现：移动2格相当于不改变筹码位置奇偶性，但移动1格改变了筹码位置奇偶性，并且移动次数无限</li><li>可以将奇数、偶数位置的筹码分别移动到一个奇数、一个偶数位置（相邻）然后将少的那个移动到多的上面即可</li></ul><p><strong>1518. 换酒问题</strong></p><p>直接模拟</p><ul><li>按照换酒规则一轮一轮地模拟，直到不能再换</li><li>或者，能换1瓶是1瓶，换回来就立刻喝掉</li></ul><p>数学</p><ul><li>设初始时有<span class="math inline">\(b\)</span>瓶酒，每<span class="math inline">\(e\)</span>瓶能换1瓶酒（每次损失<span class="math inline">\(e-1\)</span>瓶），按照能换1瓶是1瓶的方法，可以换到第一个不满足<span class="math inline">\(b-n(e-1)\ge e\)</span>的<span class="math inline">\(n=\lfloor \dfrac{b-e}{e-1}+1\rfloor\)</span>，因此总共可以喝到<span class="math inline">\(n+b\)</span>瓶</li><li>若初始时酒不能换，那么直接返回<span class="math inline">\(b\)</span></li></ul><h3 id="day-74">Day 74</h3><p><strong>944. 删列造序</strong></p><p>贪心</p><ul><li>尽可能多地保存非减序列——对每一列检查，若遇到相邻逆序对，则计数</li></ul><p><strong>1221. 分割平衡字符串</strong></p><p>贪心</p><ul><li>贪心思想：若当前串能够配对，则立即配对，若放弃机会，不会获得更多配对串</li><li>实现时，L为1，R为-1累加，若和为0，说明匹配成功一次子串，计数</li></ul><p><strong>1710. 卡车上的最大单元数</strong></p><p>贪心</p><ul><li>贪心思想：由于卡车装载箱子时，箱子是无差别的，因此肯定先挑装载能力强的箱子</li><li>按照箱子的载重排序，按序挑选箱子直到卡车装满</li></ul><p>*<strong>435. 无重叠区间</strong></p><p>贪心1</p><ul><li>贪心思想：若两个区间重叠，那么保留右边界较小的那个区间更有利于后面的区间不重叠，如果有多个右边界重叠的区间，随意选择（按照顺序选择，上一个右边界已确定，那么只要不重叠，左边界是多少都无影响）</li><li>按照右边界大小排序，首个区间就是右边界最小的那个，遍历剩下的区间，选择不重叠的区间，并更新右边界，统计选择的区间数</li><li>由于要求的是最少删除的区间数，也就是总数-最多能选择的不重叠区间数，最后返回这个计算结果即可</li></ul><p>贪心2</p><ul><li>贪心思想同上，但从删除的角度看问题，如果两个区间重叠了，那么应该保留右边界小的，删去右边界大的</li><li>按左边界or右边界排序，首区间暂定为第一个区间，遍历剩下的区间</li><li>若发生重叠，删去右边界大的那个区间（更新右边界为小的那个区间），计数</li><li>若不发生重叠，则保留并更新右边界</li></ul><h3 id="day-75">Day 75</h3><p>*<strong>376. 摆动序列</strong></p><p>动态规划</p><ul><li>注意：若元素处于边界，也可认为是“峰”或“谷”</li><li>设<span class="math inline">\(dp[i][0]\)</span>和<span class="math inline">\(dp[i][1]\)</span>分别代表以<span class="math inline">\(nums[i]\)</span>结尾的“下降摆动序列”和“上升摆动序列”（即最后一个元素为谷or峰的摆动序列）的最大长度</li><li>转移方程：<ul><li>对于<span class="math inline">\(dp[i][0]\)</span>，若<span class="math inline">\(nums[i-1]&gt;nums[i]\)</span>则说明可以选择当前元素作为结尾，并从上一个“上升摆动序列”转移，即<span class="math inline">\(dp[i][0]=\max(dp[i-1][1]+1,dp[i-1][0])\)</span>，否则<span class="math inline">\(dp[i][0]=dp[i-1][0]\)</span></li><li>对于<span class="math inline">\(dp[i][1]\)</span>，同样，若<span class="math inline">\(nums[i-1]&lt;nums[i]\)</span>，则<span class="math inline">\(dp[i][1]=\max(dp[i-1][0]+1,dp[i-1][1])\)</span>，否则<span class="math inline">\(dp[i][1]=dp[i-1][1]\)</span></li></ul></li><li>初始状态：由于单个元素也算摆动序列，则<span class="math inline">\(dp[0][0] = dp[0][1] = 1\)</span></li><li>返回：<span class="math inline">\(\max(dp[n-1][0],dp[n-1][1])\)</span></li></ul><p>贪心</p><ul><li>贪心思想：尽量保留最多的“峰”和“谷”，删去那些在坡度上的元素（or“过渡元素”）</li><li>简单证明：不失一般性，假设我们选择了某个过渡元素，并且在原序列中峰-过渡-谷，若过渡元素是局部峰值，那么峰没有被选中，可以将过渡元素换为峰；若过渡元素为局部谷值，也可以换为谷，因此选择峰谷不会破坏摆动数组的最大长度，反而可能增长</li><li>实现时，统计峰和谷的数量，先保证数组长度大于1，初始化“前一个坡度”和计数器（需要判断前一个坡度是否为0，若为0只计算1个，否则2个）</li><li>循环中，计算当前坡度，若当前坡度方向与“前一个坡度”方向相反，则计数并更新“前一个坡度”（注意0坡度的处理）</li></ul><p>*<strong>452. 用最少数量的箭引爆气球</strong></p><p>贪心</p><ul><li>受到<strong>435</strong>的启发，第一种贪心方法中，计算出最多能保留的不重叠区间数量，而把与他们重叠的区间删去</li><li>贪心思想：考察一组重叠区间，若能保证箭能穿过最小的右边界，则能穿过尽可能多的重叠区间，我们选择右边界最小的区间作为这一组重叠区间的代表</li><li>显然，若箭能穿过某组重叠区间（穿过这组区间的所有区间），它必然不能穿过下一组重叠区间（按右边界排序后，不能穿过这组区间的所有区间），即对每一组重叠区间都有一支箭穿过，才能保证所有区间都被穿过至少一次</li><li>那么只需要按照右边界顺序，从小到大挑选不重叠的区间计数，即为最少需要的箭数（此处的不重叠与435不同，若左右边界相接，也算作重叠）</li></ul><p><strong>1005. K 次取反后最大化的数组和</strong></p><p>贪心</p><ul><li>贪心思想：先尽可能把小的负数翻转过来，如果这个过程中耗尽了K，那么和即为最终答案；若没有耗尽，此时数组元素全为非负，若还剩奇数次，则翻转最小非负元素，否则不用翻转</li><li>实现时，可以在计算和的同时寻找最小非负元素，最终根据K的大小和奇偶性减去这个最小非负元素</li></ul><h3 id="day-76">Day 76</h3><p><strong>861. 翻转矩阵后的得分</strong></p><p>贪心</p><ul><li>贪心策略：由于每次翻转都是整行整列，而行翻转后交换位置不会影响列反转，因此先使得行翻转尽可能大。</li><li>显然，若最左位为1，那么行翻转会达到最大（可以证明，怎么样都会达到左边位为1的情况），则对所有最左位为0的行进行翻转</li><li>对列进行翻转时，可以发现，若一列中1的数量比0多，则对答案贡献更大，那么如果一列中0比1多（多于一半）就需要对这列翻转</li><li>使用3个二重循环可以找到答案，也可以一列一列地计算，只使用1个二重循环：假定第一列已经全部为1，从第二列开始统计1的个数，然后乘以此位的基数累加起来（需要考虑当前行是否发生翻转——看最左元素是否为0）</li></ul><p><strong>1689. 十-二进制数的最少数目</strong></p><p>贪心</p><ul><li>贪心策略：由于没有前导0，十进制数又只有01两种位，直接组合01个数，让结果中最大的那一位全由1组成，其它位都可以按照结果分配01，可以找到最少数目</li><li>实现时直接输出最大位数即可</li></ul><p><strong>1282. 用户分组</strong></p><p>贪心？Hash</p><ul><li>用Hash表统计同一个组大小的元素，将它们按照组大小进行初次分类</li><li>再遍历Hash表，将下标按照组大小分组输出</li><li>也可以一边统计，一边检查Hash表中的值的长度是否达到了组大小，若是，则直接输出并清空Hash表对应值的vector</li></ul><h3 id="day-77">Day 77</h3><p><strong>1663. 具有给定数值的最小字符串</strong></p><p>贪心</p><ul><li>贪心思想：从左到右填字母，每次填尽可能小的字母 or 从右到左填字母，每次填尽可能大的字母（把小的字母让给前面）</li><li>从右到左：对每一位，从z开始找字母，使得剩余字符串还能至少全部为a，对第一位特别处理</li><li>优化：设当前还有<span class="math inline">\(n&#39;\)</span>个字母没有填，剩余的和为<span class="math inline">\(k&#39;\)</span>，可以填的字母为<span class="math inline">\(c\)</span>，那么应该有<span class="math inline">\(n&#39;-1\le k&#39;-c \le 26(n&#39;-1)\)</span>，即<span class="math inline">\(k&#39;-26(n&#39;-1)\le c\le k&#39;-(n&#39;-1)\)</span></li><li>如果从右向左填，那么应该每次填写<span class="math inline">\(c\)</span>的上界，若上界超过26，则填z</li><li>如果从左向右填，那么应该每次填写<span class="math inline">\(c\)</span>的下界，若下界低于1，则填a</li></ul><p><strong>406. 根据身高重建队列</strong></p><p>贪心？</p><ul><li>由于k指的是比在此人前面、身高大于等于此人的人数，那么排列一个人时只需要考虑身高大于等于他的人</li><li>由于有两个维度，我们必须固定一个维度顺序方便处理，这里按照身高升序排列容易处理</li><li>排序后，假设我们正在安排第<span class="math inline">\(i\)</span>个人，他应该站的位置是当前的第<span class="math inline">\(k_i+1\)</span>个<strong>空位</strong>（若身高均不同），因为已经填充的位置是身高比他小的人，还没有填充的位置是身高大于他的人</li><li>考虑具有相同身高的人，由于<span class="math inline">\(k_i\)</span>的定义是大于等于，因此相同身高<span class="math inline">\(k_i\)</span>更大的人应该先排队（空位更多），在排序时，要按照身高升序、人数降序来排序</li><li>填充时可以利用<code>vector&lt;T&gt;::empty()</code>来代替visit数组，或使用线段树来求空位，降低时间复杂度</li></ul><p>*<strong>5. 最长回文子串</strong></p><p>动态规划</p><ul><li>由于暴力搜索需要枚举所有子串再进行线性检查，时间复杂度是立方级别，注意到如果某子串是回文串，那么可以在其基础上判断两端扩展的子串是否为回文串，这样检查的时间复杂度降至常数</li><li>设<span class="math inline">\(dp[i][j]\)</span>为“子串<span class="math inline">\([i,j]\)</span>是否为回文串”</li><li>转移方程：<span class="math inline">\(dp[i][j]=(s[i]==s[j])\wedge dp[i+1][j-1]\)</span></li><li>计算方式：按照子串长度进行计算</li><li>初始状态：长度为1时，<span class="math inline">\(dp[i][j]=true\)</span>；长度为2时，<span class="math inline">\(dp[i][j]=(s[i]==s[j])\)</span>（直接循环中计算，不用单独初始化）</li><li>返回：最长子串（在计算dp数组时更新，不用另设长度dp数组遍历）</li><li>注：对“是否为回文子串”进行动态规划较对“最长回文子串长度”进行动态规划常数小</li></ul><p>中心扩展法（滚动数组？）</p><ul><li>观察动态规划的转移方程，发现最优解的转移链条是确定的（无分叉），因此可以从某边界情况开始扩展，当不能扩展为回文串时停止</li><li>直接枚举边界情况（长度为1or2的子串）然后扩展更新长度找到最优解</li><li>注意长度计算的处理</li></ul><p>Manacher算法（TBC）</p><h3 id="day-78">Day 78</h3><p><strong>279. 完全平方数</strong></p><p>动态规划</p><ul><li>我们可以想出搜索的方法，在此基础上可以发现，对于某一数，若已经找到了最少组成个数，那么同样可以通过加其他完全平方数到达其他数</li><li>设<span class="math inline">\(dp[i]\)</span>为构成<span class="math inline">\(i\)</span>所需要的最少完全平方数</li><li>转移方程：<span class="math inline">\(dp[i]=\min_{1\le j\le \sqrt{i}}(dp[i-j^2])+1\)</span></li><li>初始状态：认为只需要0个完全平方数就可以组成0，因此<span class="math inline">\(dp[0]=0\)</span></li><li>返回：<span class="math inline">\(dp[n]\)</span></li></ul><p>数学</p><ul><li>Lagrange四平方和定理：任何一个自然数都可以被表示为4个整数的平方和，其中0被认为是完全平方数</li><li>AML三平方和定理：<span class="math inline">\(n\neq 4^k(8m+7)\)</span>当且仅当<span class="math inline">\(n\)</span>可以被3个整数的平方和表示</li><li>首先判断是否满足AML定理的条件，若不满足，则必然被4个整数平方表示（不含0，含0则落回AML，矛盾）</li><li>若满足，则有可能被1\2\3个整数平方表示，先判断是否为完全平方数，再枚举判断是否能被2个整数表示，最后返回3</li></ul><p>*<strong>494. 目标和</strong></p><p>动态规划1</p><ul><li>我们可以画出一颗二叉树，第<span class="math inline">\(i\)</span>层表示对<span class="math inline">\(nums[i]\)</span>的符号做出选择后的和，可以发现，如果在某一层上我们统计了所有可能的和以及他们对应的组成方法数，那么下一层也可以根据已有结果推导出来</li><li>设<span class="math inline">\(dp[i][j]\)</span>为<span class="math inline">\(\sum nums[i]=j\)</span>的组成方法数</li><li>转移方程：<span class="math inline">\(dp[i][j]=dp[i-1][j-nums[i]]+dp[i-1][j+nums[i]]\)</span></li><li>可以知道<span class="math inline">\(j\)</span>的取值范围为<span class="math inline">\([-\sum_{i=0}^{n-1}nums[i],\sum_{i=0}^{n-1}nums[i]]\)</span>，因此直接进行双重循环会导致数组越界（“界”指<span class="math inline">\(j\)</span>的取值范围），需要进行判断</li><li>对转移方程稍作修改：<span class="math inline">\(dp[i][j-nums[i]]=dp[i][j-nums[i]]+dp[i-1][j]\)</span>，<span class="math inline">\(dp[i][j+nums[i]]=dp[i][j+nums[i]]+dp[i-1][j]\)</span>，则只需判断<span class="math inline">\(dp[i-1][j]\)</span>是否为0，若不为0才进行计算。同时，若短序列无法构成某个<span class="math inline">\(j\)</span>值（方法数为0），那么也不可能在此序列上进行扩展，因此不必特别判断是否越界，因为越界的情况必然是从方法数为0的位置转移而来的</li><li>初始状态：<span class="math inline">\(dp[0][nums[0]]=1,dp[0][-nums[0]]+=1\)</span>（保证<span class="math inline">\(nums[0]=0\)</span>时正确）</li><li>返回：<span class="math inline">\(dp[n-1][S]\)</span></li><li>注意：<span class="math inline">\(j\)</span>需要进行偏移</li></ul><p>动态规划２</p><ul><li>观察和的性质，设符号为正的数字之和为<span class="math inline">\(\sum_+\)</span>，符号（即将）为负的数字之和为<span class="math inline">\(\sum_-\)</span>，那么<span class="math inline">\(\sum_+-\sum_-=S\)</span>，而<span class="math inline">\(2\sum_+=\sum_+-\sum_-+\sum_++\sum_-=S+\sum\)</span>，也就是我们需要选出一些元素使得<span class="math inline">\(\sum_+=(S+\sum)/2\)</span>，求所有的选择方法（0-1背包问题）</li><li>首先，排除<span class="math inline">\(S\)</span>过大和<span class="math inline">\(S+\sum\)</span>不为偶数的情况</li><li>设<span class="math inline">\(dp[i]\)</span>为构成<span class="math inline">\(i\)</span>的方法数</li><li>转移方程：<span class="math inline">\(dp[j]+=dp[j-nums[i]]\)</span>（所有可能包含当前元素转移前的状态）</li><li>计算方法：外层遍历<span class="math inline">\(i\)</span>，内层从<span class="math inline">\((S+\sum)/2\)</span>遍历到<span class="math inline">\(nums[i]\)</span>（从大到小计算，防止重复更新）</li><li>初始状态：<span class="math inline">\(dp[0]=1\)</span></li><li>返回：<span class="math inline">\(dp[(S+\sum)/2]\)</span></li></ul><h3 id="day-79">Day 79</h3><p><strong>416. 分割等和子集</strong></p><p>动态规划</p><ul><li>问题可以转化为，能否从数组中挑出一些元素，它们的和为总和的一半（0-1背包）</li><li>首先排除总和为奇数的情况</li><li>设<span class="math inline">\(dp[i]\)</span>为是否能构成<span class="math inline">\(i\)</span>（从<span class="math inline">\(dp[i][j]\)</span>简化而来）</li><li>转移方程：<span class="math inline">\(dp[j]=dp[j]\mid dp[j-nums[i]]\)</span></li><li>计算方法：遍历数组，内层循环由大到小（<span class="math inline">\(\sum/2\)</span>到<span class="math inline">\(nums[i]\)</span>）遍历<span class="math inline">\(j\)</span></li><li>初始状态：<span class="math inline">\(dp[0]=true\)</span>（未遍历数组前能构成0）</li><li>返回：<span class="math inline">\(dp[\sum/2]\)</span></li></ul><p><strong>647. 回文子串</strong></p><p>动态规划&amp;中心扩展</p><ul><li>参考<strong>5</strong>，在判断是否回文时进行统计即可</li></ul><p><strong>1143. 最长公共子序列</strong></p><p>动态规划</p><ul><li><p>观察两个等长子序列，若最后一个位置字符相等，那么LCS增加1，否则其中一个字符串跳过当前字符</p></li><li><p>设<span class="math inline">\(dp[i][j]\)</span>为字符串1前<span class="math inline">\(i\)</span>个字符与字符串2前<span class="math inline">\(j\)</span>个字符之间的LCS（0意为空串，方便初始化）</p></li><li><p>转移方程 <span class="math display">\[  dp[i][j]=\left\{ \begin{array}[ll] ddp[i-1][j-1]+1&amp;\text{if }text_1[i]=text2[j] \\\max(dp[i-1][j],dp[i][j-1])&amp;otherwise\end{array} \right.  \]</span></p></li><li><p>初始状态：<span class="math inline">\(dp[i][0]=dp[0][j]=0\)</span></p></li><li><p>返回：<span class="math inline">\(dp[m][n]\)</span></p></li></ul><h3 id="day-80">Day 80</h3><p><strong>724. 寻找数组的中心索引</strong></p><p>数组+前缀和</p><ul><li>对于<span class="math inline">\(i\)</span>，求<span class="math inline">\(\sum[0,i-1]=\sum[i+1,n-1]\)</span>相当于求<span class="math inline">\(pre[i]==pre[n]-pre[i+1]\)</span>（也可以看做求<span class="math inline">\(2\times pre[i]+nums[i]==pre[n]\)</span>）</li><li>计算前缀和数组并遍历原数组判断即可</li><li>可以发现只涉及常数个数组元素，因此可以边计算前缀和边判断，节约空间</li></ul><p>*<strong>213. 打家劫舍 II</strong></p><p>动态规划</p><ul><li>参考<strong>198</strong>，根据题意，第一个和最后一个房子不能同时偷窃，因此我们在没有第一个元素和没有最后一个元素两种情况下求最大收益，然后进行比较</li><li>可以使用滚动数组减少空间</li></ul><p><strong>516. 最长回文子序列</strong></p><p>动态规划</p><ul><li><p>这里的回文子序列和回文子串不同，子序列只需要从原序列中按序取出一些元素即可，但基本的思想还是一致的</p></li><li><p>设<span class="math inline">\(dp[i][j]\)</span>为“<span class="math inline">\([i,j]\)</span>内最长的回文子序列长度”</p></li><li><p>转移方程 <span class="math display">\[  dp[i][j]=\left\{ \begin{array}[ll]ddp[i+1][j-1]+2&amp;\text{if } s[i]==s[j]\\\max(dp[i][j-1],dp[i+1][j])&amp;otherwise\end{array} \right.  \]</span> 可见，如果相等，则添加两端字符，若不等，则需要在添加左边or添加右边两种情况中继续计算</p></li><li><p>计算方法：按照区间长度计算</p></li><li><p>初始化：<span class="math inline">\(dp[i][i]=1\)</span>（在转移循环中直接赋值）</p></li><li><p>返回：<span class="math inline">\(dp[0][n-1]\)</span></p></li><li><p>也可以从LCS的角度来看，实际上是<span class="math inline">\(s\)</span>与<span class="math inline">\(reverse(s)\)</span>之间的LCS</p></li></ul><h3 id="day-81">Day 81</h3><p>*<strong>96. 不同的二叉搜索树</strong></p><p>动态规划</p><ul><li>由于是计算BST的个数，而给出的序列升序排序，以任意一个元素为根都能构成BST，因此问题相当于求给定<span class="math inline">\(n\)</span>个节点有多少种二叉树</li><li>设<span class="math inline">\(F(i,n)\)</span>为以第<span class="math inline">\(i\)</span>个元素为根，节点数为<span class="math inline">\(n\)</span>不同的二叉树的个数，<span class="math inline">\(G(n)\)</span>为节点数为<span class="math inline">\(n\)</span>的不同二叉树个数</li><li>对于<span class="math inline">\(i\)</span>，<span class="math inline">\(F(i,n)=G(i)\times G(n-i-1)\)</span></li><li>最终要求的是<span class="math inline">\(G(n)=\sum_{i=0}^{n-1}F(i,n)=\sum_{i=0}^{n-1}G(i)\times G(n-i-1)\)</span>（转移方程）</li><li>计算方法：从<span class="math inline">\(G(0)\)</span>开始逐个计算到<span class="math inline">\(G(n)\)</span></li><li>初始化：<span class="math inline">\(G(0)=G(1)=1\)</span></li><li>返回：<span class="math inline">\(G(n)\)</span></li></ul><p>数学</p><ul><li>卡塔兰数：<span class="math inline">\(C_0=1,\, C_{n+1}=\dfrac{2(2n+1)}{n+1}C_n\)</span></li><li>递推计算到<span class="math inline">\(C_n\)</span>即可，注意long long</li></ul><p>*<strong>152. 乘积最大子数组</strong></p><p>动态规划</p><ul><li>观察题目，可以发觉此题与<strong>53</strong>相似，不过这里求的是最大乘积，如果直接套用53的转移方程会出现问题，因为最大乘积可能包含了偶数个负数因子</li><li>仔细思考状态转移，假设当前遇到的元素是正数，那么我们期待正数的乘积与之相乘，并且要尽可能大；如果是负数，我们期待负数的乘积与之相乘，并且要尽可能小，因此我们不仅要维护最大乘积，也要维护最小乘积</li><li>设<span class="math inline">\(dp[i][0]\)</span>是以<span class="math inline">\(i\)</span>结尾的乘积最大的子数组的乘积，<span class="math inline">\(dp[i][1]\)</span>是以<span class="math inline">\(i\)</span>结尾的乘积最小的子数组的乘积</li><li>转移方程：<ul><li><span class="math inline">\(dp[i][0]=\max(dp[i-1][0]*nums[i],dp[i-1][1]*nums[i],nums[i])\)</span></li><li><span class="math inline">\(dp[i][1]=\min(dp[i-1][0]*nums[i],dp[i-1][1]*nums[i],nums[i])\)</span></li></ul></li><li>初始化：<span class="math inline">\(dp[0][0]=dp[0][1]=nums[0]\)</span></li><li>返回：<span class="math inline">\(\max_i(dp[i][0])\)</span></li></ul><p>*<strong>238. 除自身以外数组的乘积</strong></p><p>数组</p><ul><li>由于不能使用除法，便不能先计算总乘积，再对每个元素除，并且一旦有0元素，此法便会失效</li><li>考虑前后缀，数组除了某个元素的总乘积，是这个元素左边的乘积乘以右边的乘积</li><li>我们只需遍历数组，分别计算对应位置左边的乘积和右边的乘积（初始时都是1），最后乘起来即可</li><li>可以节省后缀积数组的空间，计算前缀积后，直接在前缀积数组上计算答案与后缀积</li></ul><p>*<strong>44. 通配符匹配</strong></p><p>动态规划</p><ul><li><p>pattern中的?匹配任意单个字符，*匹配任意长度的字符串（可以匹配空字符串，即不使用*），考虑字符串匹配类型的动态规划</p></li><li><p>对于string和pattern中的相同字符和?，可以直接匹配；而对于pattern中的*，可以使用，也可以不使用（匹配空字符串，并跳过）</p></li><li><p>设<span class="math inline">\(dp[i][j]\)</span>为string的前<span class="math inline">\(i\)</span>个字符与pattern的前<span class="math inline">\(j\)</span>个字符相匹配（0意为空串）</p></li><li><p>转移方程 <span class="math display">\[  dp[i][j]=\left\{ \begin{array}[ll] ddp[i-1][j-1]\wedge(s[i-1][j-1])&amp;\text{if }p[j-1]\ge \text{a }\&amp;\&amp;\, p[j-1]\le\text{z} \\dp[i-1][j-1]&amp;\text{if }p[j-1]==\text{?}\\ dp[i][j-1]\vee dp[i-1][j]&amp;\text{if }p[j-1]==\text{*}\end{array} \right.  \]</span> 可以发现，当遇到pattern中的*时，可以不使用（<span class="math inline">\(dp[i][j-1]\)</span>）也可以使用（<span class="math inline">\(dp[i-1][j]\)</span>）</p></li><li><p>初始化：<span class="math inline">\(dp[0][0]=true\)</span>（空串与空串匹配），此外若pattern有开头连续的*，需要将对应<span class="math inline">\(dp[0][i]\)</span>设置为<span class="math inline">\(true\)</span></p></li><li><p>返回：<span class="math inline">\(dp[m][n]\)</span></p></li></ul><h3 id="day-82">Day 82</h3><p><strong>200. 岛屿数量</strong></p><p>DFS</p><ul><li>对每一个位置进行一次DFS，但在此之前判断此位置是否可以DFS、是否已经被访问，记录DFS次数即为答案</li><li>DFS时，可以不使用visit数组，只需要在图中将1改为0即为不可到达</li><li>DFS基本框架：首处理-&gt;标记访问-&gt;遍历所有后继节点（需要进行可达性检查）-&gt;尾处理</li></ul><p>*<strong>215. 数组中的第K个最大元素</strong></p><p>排序</p><ul><li>直接排序取<span class="math inline">\(nums[n-k]\)</span>即可</li></ul><p>堆</p><ul><li>遍历数组，维护一个大小为<span class="math inline">\(k\)</span>的小顶堆</li><li>对于数组中的每个元素：<ul><li>若堆还没满，则入队</li><li>否则，若当前元素大于等于堆顶元素，出队，并将当前元素入队</li></ul></li><li>最后返回堆顶即可</li></ul><p>分治</p><ul><li>回忆快速排序的划分过程，选取一个pivot元素，将大于它的元素移动到它的右边，将小于它的元素移动到它的左边</li><li>我们不必关心数组是否有序，只要找到的pivot刚好在<span class="math inline">\(n-k\)</span>处，那么它就是我们需要的元素</li><li>递归函数：在<span class="math inline">\(nums\)</span>的<span class="math inline">\([l,r]\)</span>之间寻找位于<span class="math inline">\(idx\)</span>的元素</li><li>递归终止：pivot在<span class="math inline">\(n-k\)</span>处</li><li>递归：若当前pivot在idx左侧，那么应该在<span class="math inline">\([pivot+1,r]\)</span>之间继续寻找；否则在idx右侧，则在<span class="math inline">\([l,pivot-1]\)</span>之间继续寻找</li><li>随机划分函数：随机选择<span class="math inline">\([l,r]\)</span>之间的的一个下标作为pivot，将此元素与位于<span class="math inline">\(l\)</span>的元素交换，即可使用普通的划分函数</li><li>划分——双指针：先移动右指针，在左右不重叠的情况下找到第一个小于pivot的元素放到左指针处，左指针右移；再移动右指针，在左右不重叠的情况下找到第一个大于pivot的元素放到右指针处，右指针左移，循环直到双指针重叠。完成后将pivot放入，返回指针索引</li></ul><h3 id="day-83">Day 83</h3><p><strong>1314. 矩阵区域和</strong></p><p>二维前缀和</p><ul><li>参考<strong>1292</strong></li><li>只需要按照要求计算子矩阵的和即可，注意判断子矩阵的边界</li></ul><p><strong>36. 有效的数独</strong></p><p>Hash</p><p>*<strong>37. 解数独</strong></p><p>回溯</p><p>回溯+状态压缩</p><h3 id="day-84">Day 84</h3><p>*<strong>51. N 皇后</strong></p><p>回溯</p><p>*<strong>46. 全排列</strong></p><p>回溯</p><p>*<strong>52. N 皇后 II</strong></p><p>回溯</p><h3 id="day-85">Day 85</h3><p>*<strong>60. 排列序列</strong></p><p>回溯</p><p>数学</p><p>*<strong>78. 子集</strong></p><p>回溯</p><p>枚举</p><h3 id="day-86">Day 86</h3><p>*<strong>90. 子集 II</strong></p><p>回溯</p><p>*<strong>39. 组合总和</strong></p><p>回溯</p><p>*<strong>40. 组合总和 II</strong></p><p>回溯</p><p>*<strong>47. 全排列 II</strong></p><p>回溯</p><h3 id="day-87">Day 87</h3><p>*<strong>77. 组合</strong></p><p>回溯</p><p>枚举</p><h3 id="need-to-review">Need To Review</h3><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">53 最大子序和</a></p><p><a href="https://leetcode-cn.com/problems/unique-paths/">62 不同路径</a></p><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/">63 不同路径 II</a></p><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">64 最小路径和</a></p><p><a href="https://leetcode-cn.com/problems/climbing-stairs/">70 爬楼梯</a></p><p><a href="https://leetcode-cn.com/problems/decode-ways/">91 解码方法</a></p><p><a href="https://leetcode-cn.com/problems/triangle/">120. 三角形最小路径和</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></p><p><a href="https://leetcode-cn.com/problems/transpose-matrix/">867 转置矩阵</a></p><p><a href="https://leetcode-cn.com/problems/rectangle-overlap/">836 矩形重叠</a></p><p><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></p><p><a href="https://leetcode-cn.com/problems/edit-distance/">72 编辑距离</a></p><p><a href="https://leetcode-cn.com/problems/integer-break/">343 整数拆分</a></p><p><a href="https://leetcode-cn.com/problems/2-keys-keyboard/">650. 只有两个键的键盘</a></p><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p><p><a href="https://leetcode-cn.com/problems/same-tree/">100 相同的树</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></p><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Note</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
